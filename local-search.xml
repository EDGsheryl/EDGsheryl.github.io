<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个人的命运啊，当然要靠自我奋斗</title>
    <link href="undefined2020/08/21/35yearsold/"/>
    <url>2020/08/21/35yearsold/</url>
    
    <content type="html"><![CDATA[<p>最近 H 哥要离职了。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>印象中 H 哥永远穿着他那一件淡蓝色的格子衬衫，是一个比较严肃的老哥，和外界很多人对黑客的印象几乎无差别，文弱白面书生，戴个眼镜斯斯文文的。H 哥粗口的方式比较特殊，“骂娘”、“他娘的”，听了总忍不住想笑。H 哥是做网络安全的，我本科也念这个，但是半路出家不研究这个了，小众。</p><p>其实我和 H 哥在工作上的交集不算多，偶尔在项目评审上听到他提到的解决方案，称不上惊艳但也算是老江湖了。</p><p>在他的项目上，我们总是以一个外行的身份提出一些外行的问题：“为啥不能像微博客户端那样方便，登录了就不退出”。</p><p>“你别老提微博行不行，……，咱们资源不够”，我当时只是觉得他有点儿气急败坏，但也不可置否咱们的现状，用户说自己是谁就是谁，用 jwt 算是很大的进步了。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>其实 H 哥入职那会儿的面试我场场都参加了，一面面 Coding，大老板特意嘱咐我对于工作几年的同行，通过一些办法考察他是不是经常写代码就可以了，然后给我洗脑说他是那边的主力，主要的大佬。面试那天，我让 H 哥写了一题倒着循环的一个题目，H 哥默不吭声的 Coding 了十几分钟，我见他没有作声，我以为把他头弄大了，结果他只是在自己的 IDE 上 coding，并没有在线 coding。</p><p>Leader 的意思其实也比较明白了，就是 coding 面走走形式，不需要太难为人家。可是你二面让我自己单独面又是啥情况。。。</p><p>二面，我让 H 哥谈谈他简历上的一些项目，然后也翻到了他的个人博客，大学参加了一个兴趣社团，给学弟学妹出了很多有意思的脑洞题目。其实当时我感觉挺有意思的，毕竟和自己的经历相似，感觉当时就差点儿露馅了。毕竟人家还没来，让他知道是一个实习生面他不太好，他面子上挂不下去，公司面子往哪搁。但是面试是我占主导的，我问了很多我熟知的问题，还问了一些关于逆向工程，才算找回点场子。我也才理解为什么面试官喜欢他所谓的面子（垃圾头条说的就是你）。</p><p>最离谱的大概就是最后终面的时候我又被拉上了，大老板和 Leader 都在，让我也问一些问题。我就问了一些比较常见的网络攻击，没想到 H 哥连怎么设置，哪个参数都记得清清楚楚，让人汗颜。 H 哥在最后一次面试给我们介绍了他的项目，其实他做的东西，我之前多多少少还是有耳闻的，我的学长和同学在北京某安全公司正在做那个项目，后来项目不知怎的流产了，后来他们做的另一个项目，也是 H 哥后来在公司里做的， H 哥在这个领域一直跑在前头。我和 Leader，大老板都觉得“卧槽，牛逼”。</p><p>其实他在那个时候就应该意识到，我们没有人懂做安全产品，在这样的环境下，需要付出多大的努力。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>上周 Leader 突然神秘地和我说，我们组可能要接 H 哥组的项目了。我有点惊讶，因为上个月 H 哥还在朋友圈发希望能做一个真实的、业内领先的产品；但是我又不奇怪，因为 H 哥做的项目都偏默默无闻型的，一个是项目本身保密性较强，另一方面来说做安全产品的效益不能体现的那么明显。</p><p>这周 H 哥交接的时候，感觉已经失去了激情，失望之余，更多的是一种疲惫，高强度的对接，H 哥不能说很大声的话了。这点我深有体会，我两次离职给他们讲代码讲得非常仔细，每个细节我都扣住了，当时讲了一个下午，讲了俩小时我就顶不住了，后半程一直在喝水。H 哥讲得不细，可能是项目太多了来不及细讲，可能是觉得本身比较易懂，也有可能是觉得自己的项目丢给我们不能善终，可惜了。</p><p>其实 H 哥在对接的时候有怒气，我能明显的感觉出来，开个权限，提供一些文档，我觉得无可厚非，但是他说这些都不应该是他的责任，无法反驳。 H 哥还希望把剩下的年假休完，可能是彻底的失望吧。</p><p>对接项目的时候，我隐隐约约知道了他离职的原因。大老板不理解，隔壁部门也不愿意配合。一些长期的但是低成本的方案，做了就是做了，没做也没关系。安全本身讲究一个大纵深，针对两台机器做安全有何可做？针对小部分机器做安全有何可做？另一方面来说，安全这个东西如何进行开发性测试也是一个难题，我们没有有经验的渗透团队，都是杂牌军。同事甚至问我能否用同一个密钥，将密钥藏于大家都找不到的地方。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>H 哥是谁的缩影？</p><p>如果说 H 哥在我们团队有什么问题，大概就是生不逢时吧，如果再晚两年进来，他可能会成为团队不可或缺的主力。另一个同事 W 哥最近也老抱怨身体越来越差，晚上整宿整宿睡不着觉，去年的他其实充满了活力，带零基础的实习生愿意和他们讲解 Python 语法，为什么这么用，为什么那样设计，如今老爱呆在自己位置上闷声做事。</p><p>35 岁，不知道是哪里定义的死线，连我一个天天喝鸡汤的女同学都知道：“程序员 35 岁不转管理岗就是失败的、不合格的”。或许人有年轻的“我命由我不由天”的轻狂，但个人命运在历史的长河当中，真的不值一提。</p><p>同学总戏称宇宙机，宇宙机，羡慕相关行业工资高。其实也不然，工资不一定高，加班也不一定狠。像在大的互联网公司，做项目有人带，每天节奏其实也就那样，每天按部就班就能平步青云；像咱们这样的公司，待遇福利应该是没得说，但做项目喜欢自己搞一套，如果没有同事 Review 那绝对只靠自觉了，像北美的项目，那已经应该是一塌糊涂了，非常真实的能跑就行，你能想象这是优秀的留学生们的杰作？</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>你永远都不会想到，你跳槽的下一家公司，会不会是一个实习生来面试你。</p><p>人生何处不青山，H 哥，祝你接下来的事业一帆风顺。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Carrer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件开发团队规范自查指南</title>
    <link href="undefined2020/04/25/software-engineering-team-cooperate/"/>
    <url>2020/04/25/software-engineering-team-cooperate/</url>
    
    <content type="html"><![CDATA[<p>除了 Coding 要求统一语言，同一格式，一个健康的项目团队应该具备一些其他素质。</p><a id="more"></a><ul><li>所有版本都是由一个持续集成服务器自动完成的吗?</li><li>是否生成并使用每日版本?</li><li>是否有问题跟踪器?</li><li>写代码之前修正所有 bug 吗?</li><li>是否有实时更新的计划表?</li><li>是否实时更新产品功能和使用方法的文档?</li><li>是否使用市面上最好的工具？</li><li>是否有完整的测试计划？</li><li>是否有专业的 UI 和 UX 设计师？</li><li>所有代码都进行 review 吗？</li><li>是否有代码规范？</li><li>新员工有培训吗？</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Software Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git、GitHub 入门笔记</title>
    <link href="undefined2020/04/25/github/"/>
    <url>2020/04/25/github/</url>
    
    <content type="html"><![CDATA[<p>4 月 7 日，全球最主流的版本控制系统——Git 迎来 15 周年纪念日，项目主要维护者 Junio C Hamano（滨野 纯）先生发邮件庆祝了这一日子。</p><a id="more"></a><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>软件的迭代是软件工程当中很自然、很重要的方法论。</p><p>从一个简单版本，到逐渐演化成一个复杂系统，如果我们想让项目健康地运行下去需要较好的质量把关，对于每一次堆砌代码都做审查。</p><p>什么是版本控制？</p><blockquote><p>版本控制（Revision control）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一代码文件案都得到同步。<a href="https://en.wikipedia.org/wiki/Version_control" target="_blank" rel="noopener" title="拓展阅读">拓展阅读</a></p></blockquote><p>按照常理来说，按下 <code>Ctrl + S</code> 也就是一种简单的版本控制方法。</p><p>例如你写完了一个模块、一个组件、一个功能，甚至一行代码、一个注释、一个空格，都可以进行版本控制。</p><p>版本控制不是目的，而是一种提高团队开发效率的手段，版本控制的核心述求是历史纪录查询和实现协同开发。</p><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><p>主流的版本控制工具主要分为两种，即集中式与分布式。</p><p>集中式版本控制工具类似网吧的管理系统，所有项目的历史文件与版本信息都存放在服务器上，而客户端就只能保存当前的状态信息。这种所有鸡蛋装在一个篮子里的模式缺点非常明显，一旦服务器损坏，项目所有的历史数据就会丢失，因此需要大规模的安全备份。比较有代表性的集中式版本控制工具有 SVN、VSS、CVS 等。</p><p>分布式版本控制工具最大的特性就是任意客户端之间可以互联，当然也包括服务器。这样一来，开发者的客户端本地也存有项目完整的历史记录，当有一个客户端损坏时，可以从另一个没有被损坏的客户端中提取历史数据，恢复之前的状态。在协同开发时，各个客户端之间可以很好地同步开发进度，避免出现重复提交等问题。</p><p>毫无疑问，分布式版本控制工具拥有更为先进的理念，其诞生的过程也是得益于网络通信技术的普及与开源社区的蓬勃发展。</p><h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>我们的故事始于 1991 年，大名鼎鼎的开源项目 Linux 问世，作者 Linus Torvalds 一跃成为 IT 界的大明星，被人们称为天才。</p><p>由于当时 Linux 社区仍采用传统的集中式版本管理，开发者提交的 patch 都汇集到 Linus 这里，让他肩上的担子很重。</p><p>在项目早期，Linus 以最原始的人力来完成 Linux 版本管理工作，包括逐条细看每个 patch、手动合并开发者提交的代码、更新版本历史信息等。</p><p>然而随着社区的逐渐壮大，Linux 的系统变得越来越庞大，代码越来越繁杂，继续依靠手动合并代码显然已经不太现实。</p><p>1999 年，一家名为 BitMover 的公司发布了一款收费的分布式版本控制软件 BitKeeper ，BitMover 的 CEO Larry 给 Linux 社区特别提供了一个可以免费使用的版本，期望 BitKeeper 能帮助 Linus 免于陷入不断加重的 Linux 内核管理工作中，但条件是不能破解这款产品。</p><p>BitMover 的初衷也很简单，借助 Linux 的名声向大家推介自己家的产品。</p><p>Linus 在使用 BitKeeper 之后不久就爱上了它，直言其是“ Best tool for the job ”。</p><p>BitKeeper 让每个开发者都拥有自己的主副本（ master copy ），完整的副本意味着可以在本地做所有事，而不是所有的 patch 只能提交到服务器（Linus）这里。</p><p>于是，Linus 可以把一些 patch 的审查工作交给 Liunx 子系统的维护者们，对于比较值得信任的维护者甚至不需要他自己再审查一遍，而他只需要对一些自己不太信任的维护者 “重点关照” 即可。2002 年，Linux 内核主线代码就全面开始使用 BitKeeper。</p><p>尽管 BitKeeper 的出现赋予了 Linux 社区更好的协同开发能力，让 Linux 内核的开发效率成倍提高，但其闭源的特性仍然让 Linus 在开源界遭到了一些非议。开源泰斗 RMS 就严厉批评 Linus 不该使用一款非自由的软件来管理世界上最大的开源项目。这些负面的声音也为之后 Linux 与 BitKeeper 的分道扬镳埋下了伏笔。</p><h2 id="分道扬镳"><a href="#分道扬镳" class="headerlink" title="分道扬镳"></a>分道扬镳</h2><p>2005 年，Linus 本人所属公司 OSDL 的老板 Andrew Morton 资助的一个项目组开始对 BitKeeper 协议进行反向编译，试图破解 BitKeeper 以创造出一个类似的开源工具。BitMover 公司很快发现了这一动作，Larry 表示这破坏了免费版 BitKeeper 的许可协议，尽管这件事或许与 Linus 本人无关，但确实严重影响了公司的利益，他们最终决定逐步停止对免费版 BitKeeper 的支持，但会给 Linux 进行工具迭代的时间。</p><p>BitMover 的做法在当时来看确实也无可厚非，他们正当地维护了自己的合法权利，挽回了因产品被破解可能带来的经济损失。</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p><p>2008 年，基于 Git 实现的代码托管平台 GitHub 面世，从此 Git 更是享誉全球。有意思的是，GitHub 当初并不是由 Git 社区的人做的，而是出自 Ruby 社区的开发者之手，两个社区在最初的关系还有些不太和睦，原因是 Git 社区的人对于 GitHub 那群人拿 Git 去做商业化感觉很不爽……当然，这些都是老开发者口中的陈年往事了。毫无疑问，GitHub 对于 Git 的普及做出了巨大的贡献。Hamano 也表示：“ 有 GitHub 替我们做文档以及用户支持，何乐而不为呢。”</p><p>和 Git 的飞速发展形成鲜明对比的是，与 Linux 分道扬镳后的 BitKeeper 每况愈下，尽管后者是世界上首个商用级的分布式版本控制工具，但在 Git 诞生之后，BitKeeper 的市场占有率断崖式下滑，几乎沦落到无人问津的地步。Git 与 BitKeeper 的不同境遇可以说是 21世纪初软件行业的缩影，传统的软件商业模式在开源浪潮的席卷下迎来了前所未有的挑战。</p><h2 id="Git-配置指南"><a href="#Git-配置指南" class="headerlink" title="Git 配置指南"></a>Git 配置指南</h2><h3 id="配置-SSH-Key"><a href="#配置-SSH-Key" class="headerlink" title="配置 SSH Key"></a>配置 SSH Key</h3><h4 id="创建-SSH-Key。"><a href="#创建-SSH-Key。" class="headerlink" title="创建 SSH Key。"></a>创建 SSH Key。</h4><p>在创建 ssh-key 的时候，请注意在 <code>$HOME/.ssh</code> 下是否已经存在，如果已经存在则没有必要创建 ssh-key（请注意检查以防止造成不必要的损失）</p><pre><code class="bash">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><p>你需要按照提示填写，或是使用默认值，一路回车。</p><p>如果一切顺利的话，可以在用户主目录里找到 <code>.ssh</code> 目录，里面有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件。</p><p>id_rsa 是私钥，不能泄露出去；id_rsa.pub 是公钥，用于服务器验证你的身份。</p><h4 id="GitHub-客户顿配置"><a href="#GitHub-客户顿配置" class="headerlink" title="GitHub 客户顿配置"></a>GitHub 客户顿配置</h4><p>在网页端打开 <code>Account settings</code>，选择 <code>SSH Keys</code> </p><p>然后点击 <code>Add SSH Key</code>，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容</p><p>这样，Github 的服务器就能够验证你的身份，你就能拉取你帐号对应的私有 Repo 了。</p><h3 id="本地安装-Git-客户端"><a href="#本地安装-Git-客户端" class="headerlink" title="本地安装 Git 客户端"></a>本地安装 Git 客户端</h3><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><pre><code class="bash">$ sudo apt-get install git</code></pre><h4 id="配置本地git"><a href="#配置本地git" class="headerlink" title="配置本地git"></a>配置本地git</h4><p>其实我一直没有理解这部分的配置的用途。</p><pre><code class="bash">$ git config --global user.email &quot;email@youremail.com&quot;$ git config --global user.name &quot;yourname&quot;</code></pre><h4 id="提交-Commit-到-branch"><a href="#提交-Commit-到-branch" class="headerlink" title="提交 Commit 到 branch"></a>提交 Commit 到 branch</h4><pre><code class="bash">$ git add -A$ git commit -m &quot;commit message&quot;$ git push origin master</code></pre><h2 id="Git-进阶推荐"><a href="#Git-进阶推荐" class="headerlink" title="Git 进阶推荐"></a>Git 进阶推荐</h2><p>在网络上学习 Git 的参考资料有很多，依靠实践是学习进步的较快方法</p><p><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://my.oschina.net/editorial-story/blog/3288572" target="_blank" rel="noopener">Git 15 周年：当年的分道扬镳，成就了今天的开源传奇</a></li><li><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E7%AE%80%E5%8F%B2" target="_blank" rel="noopener">Git 简史</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains Quest Challenge 3</title>
    <link href="undefined2020/03/14/jetbrain_quest_3/"/>
    <url>2020/03/14/jetbrain_quest_3/</url>
    
    <content type="html"><![CDATA[<p>第三弹 Quest，这一次的难度比较高，最后的奖品是一个 20% OFF 的 Discounts Code，可能就没有之前那么香</p><a id="more"></a><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/annualreport-2019.png" srcset="undefined" alt=""></p><p>JetBrains 成立 20 周年了，如果不去了解 JetBrains 的历史，也不会知道 IDEA 是 2000 年推出的 IDE</p><p>IDE 将一些工具集成化、简化、可视化，从而达到降低学习成本、提高工作效率，感谢 JetBrains 的 Innovation，为 Coding 带来更多乐趣</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/JetBrains-Products.png" srcset="undefined" alt=""></p><p>第三轮的题目同样来自一则推文</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/twitter3.png" srcset="undefined" alt=""></p><h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><p>特征其实不是很明显，就 base64 一下吧</p><pre><code class="Text">Have you seen the post on our Instagram account?</code></pre><p>(是一个导流广告 x)</p><h1 id="Instagram"><a href="#Instagram" class="headerlink" title="Instagram"></a>Instagram</h1><p>吃下这发安利，我们可以到对应页面看到这个 post</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/Instagram.png" srcset="undefined" alt=""></p><pre><code class="text">Welcome to the final Quest! You should start on the Kotlin Playground: https://jb.gg/kotlin_questP.S. If you don’t know about the #JetBrainsQuest, it’s not too late to find out.</code></pre><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><p>实际上这个 n 需要多试几次，因为之前那个移位密码也有很多 #，实际上应该和之前一样是 <code>n=3</code></p><pre><code class="Kotlin">fun main() {   val s = &quot;Zh#kdyh#ehhq#zrunlqj#552:#rq#wkh#ylghr#iru#wkh#iluvw#hslvrgh#ri#wkh#SksVwrup#HDS1#Li#zh#jdyh#|rx#d#foxh/#lw#zrxog#eh#hdv|#dv#sl1&quot;   val n: Int = 3;   for (c in s) {       print(c - n)   }}</code></pre><p>然后解出</p><pre><code class="text">We have been working 22/7 on the video for the first episode of the PhpStorm EAP. If we gave you a clue, it would be easy as pi.</code></pre><h1 id="Pi-equals-to-3-14…"><a href="#Pi-equals-to-3-14…" class="headerlink" title="Pi equals to 3.14…."></a>Pi equals to 3.14….</h1><p>指向了一个视频，我 0.25 倍速度也没看出个所以然，看了别人才知道是一个 URL 被改了，改了的 URL 是最终的线索</p><p>视频跳之 3:14 有蜜汁转场效果</p><iframe width="560" height="315" src="https://www.youtube.com/embed/OtQuAr3n87c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><a href="https://jb.gg/31415926" target="_blank" rel="noopener">https://jb.gg/31415926</a></p><h1 id="猝不及防的快问快答"><a href="#猝不及防的快问快答" class="headerlink" title="猝不及防的快问快答"></a>猝不及防的快问快答</h1><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/questions.png" srcset="undefined" alt=""></p><p>答完之后会得到下一步的线索</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/quiz-done.png" srcset="undefined" alt=""></p><h1 id="藏头诗"><a href="#藏头诗" class="headerlink" title="藏头诗"></a>藏头诗</h1><pre><code class="text">Not Everything Today Does All You Could Ask. Lessons Learned From Other Relevant Solutions, Possibly Even Another Kind Emerge. Risking Sometimes Being Liberal Or Generous Proves Ordinary Simple Tests Infinitely More Annoying. Get Examining Hidden Initial Designated Early Symbols. They Have Everything Needed, Except Xerox, To Completely Level Up Everything.</code></pre><p>一段让人摸不着头脑的文字，看了网友表示这是 acronym</p><pre><code class="text">.Net day call for speakers blog post image hides the next clue</code></pre><h1 id="NET-DAY"><a href="#NET-DAY" class="headerlink" title=".NET DAY"></a>.NET DAY</h1><p>通过搜索引擎找到这个页面</p><p><a href="https://blog.jetbrains.com/dotnet/2020/02/13/jetbrains-net-day-online-2020-call-speakers/" target="_blank" rel="noopener">https://blog.jetbrains.com/dotnet/2020/02/13/jetbrains-net-day-online-2020-call-speakers/</a></p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/clues-in-pic.png" srcset="undefined" alt=""></p><p>线索很好找， <code>you_are_looking_for_build_201-6303</code></p><h1 id="Tip-today"><a href="#Tip-today" class="headerlink" title="Tip today"></a>Tip today</h1><p>这一步就比较硬核了，你需要下载安装，好大啊。。。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/eap.png" srcset="undefined" alt=""></p><p>然后算出答案想必不是什么难事吧！</p><h1 id="神秘代码"><a href="#神秘代码" class="headerlink" title="神秘代码"></a>神秘代码</h1><p>46023125</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>JetBrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains Quest Challenge 2</title>
    <link href="undefined2020/03/13/jetbrain_quest_2/"/>
    <url>2020/03/13/jetbrain_quest_2/</url>
    
    <content type="html"><![CDATA[<p>根据上一轮的 Quest 的最后邮件提示，我们可以知道第二轮举行时间为 2020-03-11 19:00:00</p><a id="more"></a><p>第二轮的题目也是一则推文</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/twitter-2.png" srcset="undefined" alt=""></p><h1 id="Reverse-the-string"><a href="#Reverse-the-string" class="headerlink" title="Reverse the string"></a>Reverse the string</h1><p>我们可以看出这可能是一个反转的字符串</p><pre><code class="python">print(&quot;.spleh A+lrtC/dmC .thgis fo tuo si ti semitemos ,etihw si txet nehw sa drah kooL .tseretni wohs dluohs uoy ecalp a si ,dessecorp si xat hctuD erehw esac ehT .sedih tseuq fo txen eht erehw si ,deificeps era segaugnal cificeps-niamod tcudorp ehT&quot;[::-1])</code></pre><p>可以得到</p><pre><code class="Text">The product domain-specific languages are specified, is where the next of quest hides. The case where Dutch tax is processed, is a place you should show interest. Look hard as when text is white, sometimes it is out of sight. Cmd/Ctrl+A helps.</code></pre><h1 id="Hidden-Words"><a href="#Hidden-Words" class="headerlink" title="Hidden Words"></a>Hidden Words</h1><p>看起来是进入 <a href="https://www.jetbrains.com/mps/" target="_blank" rel="noopener">https://www.jetbrains.com/mps/</a> 这个页面了</p><p>提到了 Dutch Tax，我们到相关公司机构的最佳实践页面寻找线索，果然在 PDF 界面发现了隐藏的文字</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/hidden-words.png" srcset="undefined" alt=""></p><p>复制出这段话</p><pre><code class="text">This is our 20th year as a company,we have shared numbers in our JetBrainsAnnual report, sharing the section with18,650 numbers will progress your quest.</code></pre><p>实际上这个页面有点难找，我是根据搜索结果，然后推断出今年的 URL <a href="https://www.jetbrains.com/company/annualreport/2019/" target="_blank" rel="noopener"></a></p><h1 id="Sharing-the-section"><a href="#Sharing-the-section" class="headerlink" title="Sharing the section"></a>Sharing the section</h1><p>根据上面数字提示 18,650 我在页面搜索了 18K、18650 等等，都没找到结果，最后发现有个 18000，其实图中数字加起来是 18650</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/sharing.png" srcset="undefined" alt=""></p><p>点击上方的 sharing 按钮就可以得到下一个提示了</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/sharing-2.png" srcset="undefined" alt=""></p><pre><code class="text">I have found the JetBrains Quest! Sometimes you just need to look closely at the Haskell language, Hello,World! in the hackathon lego brainstorms project https://blog.jetbrains.com/blog/2019/11/22/jetbrains-7th-annual-hackathon/ #JetBrainsQuest https://www.jetbrains.com/company/annualreport/2019/ 来自 @JetBrains</code></pre><h1 id="Hello-World-with-Haskell"><a href="#Hello-World-with-Haskell" class="headerlink" title="Hello, World with Haskell"></a>Hello, World with Haskell</h1><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/comic.png" srcset="undefined" alt=""></p><p>仔细看上方其实是有一段文字的，火星英文！</p><pre><code class="text">d1D j00 kN0w J378r41n2 12 4lW4Y2 H1R1N9? ch3CK 0u7 73h K4r33r2 P493 4nD 533 1f 7H3r3 12 4 J08 F0r J00 0R 4 KW357 cH4LL3n93 70 90 fUr7h3r @ l3457.</code></pre><pre><code class="text">Did you know Jetbrains is always hiring? Check out the careers page and see if there is a job for you or for newest challenge to go further at least.</code></pre><h1 id="Find-the-job"><a href="#Find-the-job" class="headerlink" title="Find the job"></a>Find the job</h1><p>找到 Hiring 的界面，然后去 Jobs 的页面寻找，发现有一个 <code>Fearless Quester</code> 的职位</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/job.png" srcset="undefined" alt=""></p><p>里面的有用信息应该如下：</p><pre><code class="text">To progress with your quest what you’ll need:- To check out what we have for game developers.- Be geeky enough to remember how you used to cheat at Konami games.- Try cheating on the page.</code></pre><h1 id="Konami-Cheating-Code"><a href="#Konami-Cheating-Code" class="headerlink" title="Konami Cheating Code"></a>Konami Cheating Code</h1><p>这一步其实挺难的，你得知道有这么一个地方，然后输入秘籍，经典的 上上下下左右左右 BABA</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/game_page.png" srcset="undefined" alt=""></p><p>然后通关小游戏就能获得奖励辣</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/cong-letter2.png" srcset="undefined" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>JetBrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains Quest Challenge 1</title>
    <link href="undefined2020/03/10/jetbrain_quest_1/"/>
    <url>2020/03/10/jetbrain_quest_1/</url>
    
    <content type="html"><![CDATA[<p>JetBrains 给大家发福利了，免费三个月 All package 的 Coupon Code，只需要参加官方举办的 Quest Challenge，这是一个程序猿解密游戏</p><a id="more"></a><p>JetBrains 20 周年纪念，在 Twitter 上发布了这样一则推文</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/twitter.png" srcset="undefined" alt=""></p><h1 id="Hex-to-char"><a href="#Hex-to-char" class="headerlink" title="Hex to char"></a>Hex to char</h1><p>我们可以看出这可能是一段十六进制的数字，那么他可能给的是一个字符串。</p><pre><code class="python">quest = &quot;48 61 76 65 20 79 6f 75 20 73 65 65 6e 20 74 68 65 20 73 6f 75 72 63 65 20 63 6f 64 65 20 6f 66 20 74 68 65 20 4a 65 74 42 72 61 69 6e 73 20 77 65 62 73 69 74 65 3f&quot;ans = &quot;&quot;for ch in quest.split(&#39; &#39;):    ans += chr(int(ch, 16))print(ans)</code></pre><p>可以得到</p><pre><code class="Text">Have you seen the source code of the JetBrains website?</code></pre><h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><p>在官网页面，空白处右键，查看源码，你可以看到一段 HTML 注释</p><pre><code class="html">        &lt;!--      O{o)xxx|===============-      OWelcome to the JetBrains Quest.What awaits ahead is a series of challenges. Each one will require a little initiative, a little thinking, and a whole lot of JetBrains to get to the end. Cheating is allowed and in some places encouraged. You have until the 15th of March at 12:00 CET to finish all the quests.Getting to the end of each quest will earn you a reward.Let the quest commence!JetBrains has a lot of products, but there is one that looks like a joke on our Products page, you should start there... (hint: use Chrome Incognito mode)It’s dangerous to go alone take this key: Good luck! == Jrrg#oxfn$                 O-===============|xxx(o}                 O--&gt;</code></pre><p>欢迎来到JetBrains Quest。</p><p>未来将面临一系列挑战。 每个人都需要一点努力，一点思考和很多 JetBrains 才能达到终点。允许作弊，在某些地方鼓励作弊。您必须在 3 月 15 日欧洲中部时间 12:00 之前完成所有任务。<br>到达每个任务的结尾将为您带来奖励。<br>让任务开始！</p><p>JetBrains有很多产品，但是我们的“产品”页面上有一个看起来像个玩笑的产品，您应该从那里开始…（提示：使用 Chrome 隐身模式）</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/what-is-JK.png" srcset="undefined" alt=""></p><p>你这个 JK 是什么鬼啦！</p><h1 id="Count-the-prime"><a href="#Count-the-prime" class="headerlink" title="Count the prime"></a>Count the prime</h1><p>轻拿鼠标点击，打开一个对话框</p><pre><code class="Text">You have discovered our JetBrains Quest! If you don’t know what this is, you should start from Twitter, Facebook or LinkedIn.To continue to the next challenge you need to go to the following link… But there is a problem, the last 3 digits are missing:https://jb.gg/###To get these digits you need to know how many prime numbers there are between 500 and 5000Good Luck!</code></pre><p>您已发现我们的JetBrains Quest！ 如果您不知道这是什么，则应从Twitter，Facebook或LinkedIn开始。</p><p>要继续下一个挑战，您需要转到以下链接…但是存在问题，后三位数字丢失：</p><p><a href="https://jb.gg/###" target="_blank" rel="noopener">https://jb.gg/###</a></p><p>要获得这些数字，您需要知道 500 和 5000 之间有多少个质数</p><p>祝好运！</p><p>想像一下，如果是一个宅宅，怀着怎样的心情，点开了 JK，发现和想象中的不太一样 QwQ。。。</p><pre><code>isPrime = lambda x: all(x % i != 0 for i in range(int(x ** 0.5) + 1)[2:])ans = 0for num in range(500, 5000):    if isPrime(num):        ans += 1print(ans)</code></pre><p>然后打开对应的网址</p><h1 id="Trace-the-issue"><a href="#Trace-the-issue" class="headerlink" title="Trace the issue"></a>Trace the issue</h1><p>得到了一张新的图片，应该和台球无关吧。。。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/mps.png" srcset="undefined" alt=""></p><p>图上有 YT，youtrack 是一个项目管理工具，这一步我认为是最难的地方，你得知道这个工具是干嘛的，然后发现他其实有公开的 issue，找到对应的 issue 就能知道下一步提示了</p><pre><code class="text">“The key is to think back to the beginning.” – The JetBrains Quest team.Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh/#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw/#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul}h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟EhfdxvhFrgh†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul}h1#kwwsv=22zzz1mhweudlqv1frp2surpr2txhvw2</code></pre><p>我以为只是倒过来，我想了半天，以为是弗吉尼亚密码，解密网站告诉我 key 是 ddd，那不就是凯撒吗。。。</p><pre><code class="Python">quest = &quot;Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh/#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw/#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul}h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟EhfdxvhFrgh†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul}h1#kwwsv=22zzz1mhweudlqv1frp2surpr2txhvw2&quot;ans = &quot;&quot;for i in range(len(quest)):    ans += chr(ord(quest[i]) - 3)print(ans)</code></pre><p>接下来的你懂了吧！</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/cong-letter1.png" srcset="undefined" alt=""></p><p>除了本次的奖励之外，其实邮件里还有一些细节</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jetbrains-quest/next-clues.png" srcset="undefined" alt=""></p><p>比如下面的时间，他是一个 UNIX 时间戳。</p><p>还有那一行 <code>Y0U H4V3</code> 的信息都比较嗨客</p><p>至于最后那个移位密码是怎么看出来的，其实在之前就有提示 Good luck! == Jrrg#oxfn$</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>JetBrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 Travis CI 部署博客</title>
    <link href="undefined2020/02/24/travis/"/>
    <url>2020/02/24/travis/</url>
    
    <content type="html"><![CDATA[<p>CI/CD 讲的是软件开发通过软件工程的手段优化开发流程，提高开发质量的一个手段。</p><a id="more"></a><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/travis/ci_tools.png" srcset="undefined" alt=""></p><p>CI/CD 并不是指的某一个工具，但是通常好的 CI/CD 工具都拥有相同的功能。</p><h1 id="持续集成（Continuous-integration）"><a href="#持续集成（Continuous-integration）" class="headerlink" title="持续集成（Continuous integration）"></a>持续集成（Continuous integration）</h1><p>在我看来，持续集成分为两个方面来看待，其一是集成，就是将代码不断合并到一个大的系统上。然后是持续，持续体现在可能这个代码仓库不断有频繁的贡献，然后得到不断的反馈。在我看来持续集成是一个源码控制的工具。</p><p>采用持续集成时，开发人员会定期将代码变更合并到一个中央存储库中，之后系统会自动运行构建和测试操作。持续集成的主要目标是更快发现并解决缺陷，提高软件质量，并减少验证和发布新软件更新所需的时间。</p><p>通常，代码的一次 PR 操作会触发一次 CI，CI 会对这次 PR 合并之后的代码做静态检测（包括代码风格、代码规范），进行单元测试，然后进行构建（Build）。</p><h1 id="持续部署（Continuous-Deployment）or-持续交付（Continuous-Delivery）"><a href="#持续部署（Continuous-Deployment）or-持续交付（Continuous-Delivery）" class="headerlink" title="持续部署（Continuous Deployment）or 持续交付（Continuous Delivery）"></a>持续部署（Continuous Deployment）or 持续交付（Continuous Delivery）</h1><p>其实讲的大体上应该是一个东西，在代码合并入仓库之后，将二进制文件或者是源代码等部署到测试环境，或者是生产环境。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/travis/jarvis.jpg" srcset="undefined" alt=""></p><p>Travis 的取名，会不会和 Jarvis 有几分关系呢？</p><h1 id="通过-Travis-自动更新-Github-Page"><a href="#通过-Travis-自动更新-Github-Page" class="headerlink" title="通过 Travis 自动更新 Github Page"></a>通过 Travis 自动更新 Github Page</h1><p><a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> Travis CI 只支持 Github，不支持其他代码仓库。</p><p>登录并授权过后只需要将需要 CI 的 repo 勾上，然后进行进一步配置。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/travis/travis_index.png" srcset="undefined" alt=""></p><p>如图所示，我将我的 Github Page 和一个名为 blog-travis 的仓库分开，后者是我使用的基于 Hexo 的源码，每一次 blog-travis repo 的更新都将触发一次 CI job。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/travis/travis_setting.png" srcset="undefined" alt=""></p><p>点击 Setting，我们就能够设置触发条件、定义 CI 脚本的环境变量等。</p><p>最后，使用 Travis CI 的关键就在于编写一个执行流程的 YAML 文件，命名为 <code>.travis.yml</code>，保存在你项目根目录下。该 YAML 文件指定了环境，执行命令。当然在 CI/CD 阶段我们可能需要打包镜像，或者是使用 Token，密钥，这部分可以通过 Travis CI 的环境变量传入，也可以通过加密文件上传，线上解密的方式传输。</p><pre><code class="yaml">language: node_jsos: linuxcommitter_from_gh: truenode_js:  - 13.1.0before_install:  - npm install -g hexo-cli# Start: Build Lifecycleinstall:  - npm install  - npm install hexo-deployer-git --savescript:  - hexo clean  - hexo generateafter_script:  - sed -i &quot;s/gh_token/${GITHUB_TOKEN}/g&quot; ./_config.yml  - hexo deploy# End: Build LifeCycle</code></pre><p>秘诀就在于将环境变量替换成 URL，然后使用这个 Token 更新你的 repo</p><pre><code class="yaml">deploy:  type: git  repo: https://gh_token@github.com/edgsheryl/edgsheryl.github.io.git  branch: master</code></pre><p>在配置完 CI/CD 之后，我每次更新博客只需要更新我的 Markdown 文件，Commit and Push 就能够完成博客的更新了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络入门</title>
    <link href="undefined2019/11/29/network_1/"/>
    <url>2019/11/29/network_1/</url>
    
    <content type="html"><![CDATA[<p>网络构建成了社会，计算机网络也只是其中一个。</p><p>计算机网络对于计算机的发展起到了相当关键的作用。</p><p>但是从现有的计算机科学整体角度来看，计算机网络的出现会不会是历史必然呢？</p><a id="more"></a><h1 id="现有的分层体系"><a href="#现有的分层体系" class="headerlink" title="现有的分层体系"></a>现有的分层体系</h1><p>网络理论模型有很多种，尽管理论有少许区别，但是核心内容应该是一样的。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/network/model.png" srcset="undefined" alt=""></p><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>OSI七层协议模型分为：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）</p><h2 id="TCP-IP-体系结构"><a href="#TCP-IP-体系结构" class="headerlink" title="TCP/IP 体系结构"></a>TCP/IP 体系结构</h2><p>TCP/IP 体系结构分为：应用层，运输层，网络层，网络接口层</p><h2 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h2><p>五层体系结构分为：应用层、运输层、网络层、数据链路层和物理层</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>三个模型中都有的是应用层、运输层、网络层。在实际的开发当中，我们往往也只提及这三层。我们可以发现 TCP/IP 模型当中包含了 OSI 的应用层、表示层、会话层，然后使用网络接口层包括了数据链路层和物理层。</p><p>五层协议应该是对两种模型的取舍的结果。因此我们初步得出结论：</p><ul><li>OSI 模型当中的数据链路层、物理层分离是合理的</li><li>OSI 模型当中的应用层、表示层、会话层分开不合理</li></ul><h2 id="为什么要提及网络分层模型"><a href="#为什么要提及网络分层模型" class="headerlink" title="为什么要提及网络分层模型"></a>为什么要提及网络分层模型</h2><p>因为网络分层模型很好的解释了网络是如何工作的。一次 HTTP 请求，一层一层剥开，就可以很清楚了解每一层干了什么，每一层的意义是什么。</p><h1 id="应用层（Application）"><a href="#应用层（Application）" class="headerlink" title="应用层（Application）"></a>应用层（Application）</h1><p>应用层位于 OSI 模型的最上层，有很多常见的协议，例如 HTTP（超文本传输协议，我们熟悉的网页）、FTP（文件传输协议，FTP 服务器）、SMTP（简单邮件传输协议）、POP3（邮局协议第三版）。</p><p>应用层提供为应用软件而设的接口，以设置与另一应用软件之间的通信。</p><p>比较令人惊讶的应该是 DNS 了，他是七层的，针对域名的转发通常称作七层转发。</p><p>部分博客谈到的 Gopher、TELNET、RPC 等均被维基百科认为是七层的。</p><h1 id="表示层（Presentation）"><a href="#表示层（Presentation）" class="headerlink" title="表示层（Presentation）"></a>表示层（Presentation）</h1><p>把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><p>起初我也很困惑。</p><pre><code>例如 PC 程序与另一台计算机进行通信其中一台计算机使用扩展二一十进制交换码（EBCDIC）而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 　　</code></pre><p>显然该层被弃用的理由不难推测，大家约定俗成就行，也与网络无关。</p><p>而维基百科给出的理由是应用层的 HTTP、FTP、Telnet 等协议有类似的功能。传输层的 TLS/SSL 也有类似功能。</p><h1 id="会话层（Session）"><a href="#会话层（Session）" class="headerlink" title="会话层（Session）"></a>会话层（Session）</h1><p>负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p><p>可以感觉在会话层并像其他层级那样是垂直的，更像一点并行的关系。</p><p>维基百科给出的理由是应用层的HTTP、RPC、SDP、RTCP等协议有类似的功能。</p><h1 id="应用层小节"><a href="#应用层小节" class="headerlink" title="应用层小节"></a>应用层小节</h1><p>我们可以看到表示层和会话层被取代的理由基本都是由于应用层协议本身考虑到了相应的问题，给出了相应的解决方法，这两层已经没有了存在的意义。</p><h1 id="应用层协议选讲"><a href="#应用层协议选讲" class="headerlink" title="应用层协议选讲"></a>应用层协议选讲</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>一个 HTTP 请求返回的东西，不只是我们显示在浏览器当中的网页（不是 HTML）。</p><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p><img src="https://image-static.segmentfault.com/287/070/2870706633-5bcbdc404eb45_articlex" srcset="undefined" alt=""></p><p>如图是一次 HTTP 请求的请求报文。如果对某个参数想了解更多请自行搜索。</p><pre><code>HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞Wrox Homepage＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞</code></pre><p>如上，则是 HTTP 响应报文，响应报文分为四个部分，第一行为 HTTP_STATUS，然后接下来第二部分是响应的 header，第三部分是一个空行，第四部分则是响应报文的 body。第三部分恒定是一个空行。</p><h3 id="HTTP-长连接"><a href="#HTTP-长连接" class="headerlink" title="HTTP 长连接"></a>HTTP 长连接</h3><p>客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。</p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP/2 相对于 HTTP/1.1 来说做出了很多优化。</p><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">演示链接</a> 实际上，这个网页速度应该左边比右边慢，但是我测出来右边反而比左边慢。。。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><img src="https://pic3.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_hd.jpg" srcset="undefined" alt=""></p><p>如图所示。HTTP/2 可以实现多流并行，而不是建立多个 TCP 连接来加速。</p><h4 id="报头压缩"><a href="#报头压缩" class="headerlink" title="报头压缩"></a>报头压缩</h4><p><img src="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/hpack_header_compression.png" srcset="undefined" alt=""></p><p>通过这种减少冗余的方式优化。</p><h4 id="服务器端推送"><a href="#服务器端推送" class="headerlink" title="服务器端推送"></a>服务器端推送</h4><p>服务器端推送通过预测客户端需要的资源，主动推送。</p><p>例如：客户端请求index.html，服务器端能够额外推送script.js和style.css。如果客户端在有缓存的情况下请求，则会通知服务器不需要哪些资源。</p><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p> <img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/network/binary.png" srcset="undefined" alt="img"> </p><p>HTTP/2 性能提升核心在于此，他采用二进制传输，而不是文本格式。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>如果要请求 image.google.com，我们需要知道对应的 ip 地址。</p><p>以查询 image.google.com 为例：</p><ul><li>客户端发送查询报文”query  image.google.com”至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。</li><li>如果记录老化或不存在，则：<br><del>改用百度</del> <ol><li>DNS服务器向根域名服务器发送查询报文”query  image.google.com”，根域名服务器返回顶级域 .com 的权威域名服务器地址。</li><li>DNS服务器向 .org 域的权威域名服务器发送查询报文”query  image.google.com”，得到二级域 .google.com 的权威域名服务器地址。</li><li>DNS服务器向 .google.com 域的权威域名服务器发送查询报文”query image.google.com”，得到主机 image 的A记录，存入自身缓存并返回给客户端。<br>当然谁知道谁就返回了。</li></ol></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h3><p>RPC（Remote Procedure Call）远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><h3 id="RPC-与-RESTful-的区别"><a href="#RPC-与-RESTful-的区别" class="headerlink" title="RPC 与 RESTful 的区别"></a>RPC 与 RESTful 的区别</h3><p>RESTful 比较特别的有：</p><ul><li>利用 HTTP 方法让接口统一化</li></ul><pre><code class="Text">GET /posts     获取文章             GET /getPosts       获取文章 POST /posts    发布文章             GET /addPosts       发布文章 PUT /posts     修改文章             GET /editPosts      修改文章 DELETE /posts  删除文章             GET /deletePosts    删除文章 </code></pre><p>左右的区别在于左边有 HTTP method 的区别，同时都对 posts 进行操作；右边则是动宾短语，用谓语表达操作行为，用宾语表达操作对线。左边符合 REST 设计风格。</p><p>相应的，由于 RPC 的设计为函数调用，其命名方式应该接近于右边采用谓语命名法。</p><ul><li>利用HTTP状态码返回状态信息</li></ul><pre><code class="Text">Status Code: 200 OKStatus Code: 400 Bed RequestStatus Code: 404 Not FoundStatus Code: 500 Internal Server Error </code></pre><p>REST 依赖 HTTP Status Code 来判断请求结果，而 RPC 调用应该分为调用的网络请求是否成功，调用成功后结果是否成功。</p><p>RESTful 是建立在 HTTP 的基础上。gRPC 就是在 HTTP 上进行数据传输的；Netty 是基于 TCP、UDP 上进行传输的。</p><h3 id="RPC-与-SDK-的区别"><a href="#RPC-与-SDK-的区别" class="headerlink" title="RPC 与 SDK 的区别"></a>RPC 与 SDK 的区别</h3><p>之前我与 Leader 和其他同事争论其中的区别。</p><p>SDK 的代码应该是在本地运行的。而 RPC 的业务代码是在服务器端的。</p><p>但是 SDK 可以包含网络请求啊，网络请求之后那部分算不算 RPC 呢？</p><p>关键其实就是如何定义 Remote，如何定义 Procedure。</p><p>你品，你细品。</p><h3 id="RPC-是如何工作的"><a href="#RPC-是如何工作的" class="headerlink" title="RPC 是如何工作的"></a>RPC 是如何工作的</h3><p><img src="https://dubbo.apache.org/img/blog/rpc/rpc-work-principle.png" srcset="undefined" alt="img"></p><p>如图所示步骤 1-10：</p><ol><li>Client 像调用本地服务似的调用远程服务；</li><li>Client Stub 接收到调用后，将方法、参数序列化</li><li>客户端通过 sockets 将消息发送到服务端</li><li>Server Stub 收到消息后进行解码（将消息对象反序列化）</li><li>Server Stub 根据解码结果调用本地的服务</li><li>本地服务执行(对于服务端来说是本地执行)并将结果返回给 Server Stub</li><li>Server Stub 将返回结果打包成消息（将结果消息对象序列化）</li><li>服务端通过 sockets 将消息发送到客户端</li><li>Client Stub 接收到结果消息，并进行解码（将结果消息发序列化）</li><li>客户端得到最终结果。</li></ol><h3 id="jsonRPC"><a href="#jsonRPC" class="headerlink" title="jsonRPC"></a>jsonRPC</h3><p>JSON-RPC是一个无状态且轻量级的远程过程调用(RPC)协议。</p><p>我司之前用的大概就是 jsonRPC 改，并命名为 XX_RPC，（这玩意儿真的好用吗 - -），然后我还甚至能 fake Client Stub 和 Server Stub。</p><pre><code class="Text">--&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: [42, 23], &quot;id&quot;: 1}&lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19, &quot;id&quot;: 1}</code></pre><p>请求对象：</p><ul><li><p>jsonrpc</p><p>指定JSON-RPC协议版本的字符串，必须准确写为“2.0”</p></li><li><p>method</p><p>为调用的方法名</p></li><li><p>params</p><p>传递的参数</p></li><li><p>id    </p><p>已建立客户端的唯一标识id</p></li></ul><p>响应对象：</p><ul><li><p>jsonrpc</p><p>指定JSON-RPC协议版本的字符串，必须准确写为“2.0”</p></li><li><p>result</p><p>该成员在成功时必须包含。<br>服务端中的被调用方法决定了该成员的值。</p></li><li><p>error</p><p>该成员在失败是必须包含。</p></li><li><p>id    </p><p>已建立客户端的唯一标识id</p></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC 设计上是分层的，底层支持不同的协议。</p><ul><li><p><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md" target="_blank" rel="noopener">gRPC-web</a></p></li><li><p><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener">gRPC over HTTP2</a></p></li></ul><p>gRPC 在后端之间调用往往采用 ** gRPC over HTTP2 **。</p><p>gRPC-web 多用于前端，实际上 gRPC-web 解决的是 REST 部分是 RPC 翻译器的问题。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/network/grpc-web.png" srcset="undefined" alt="img"></p><p><a href="https://juejin.im/post/5c4e791f6fb9a049ba41f6b0" target="_blank" rel="noopener">REST 的替代者：Envoy + gRPC-Web</a></p><p>值得注意的是前后端交互需要 Envoy 来转换。而 Envoy 扮演的角色是：</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/network/envoy.png" srcset="undefined" alt="img"></p><h1 id="部分参考文献"><a href="#部分参考文献" class="headerlink" title="部分参考文献"></a>部分参考文献</h1><p><a href="https://halfrost.com/websocket/#websocket" target="_blank" rel="noopener">全双工通信的 WebSocket</a><br><a href="https://dubbo.apache.org/zh-cn/blog/rpc-introduction.html" target="_blank" rel="noopener">浅谈 RPC</a><br><a href="https://ddnd.cn/2018/12/19/rpc-and-restful/" target="_blank" rel="noopener">RPC和RESTful API入门篇</a><br><a href="http://hengyunabc.github.io/thinking-about-grpc-http2/" target="_blank" rel="noopener">思考gRPC:为什么是HTTP/2</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">域名系统——wiki</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 是 Socket 吗？</title>
    <link href="undefined2019/11/28/websocket/"/>
    <url>2019/11/28/websocket/</url>
    
    <content type="html"><![CDATA[<p>WebSocket 带上了个 socket，但是两者差别应该还是挺大的。</p><a id="more"></a><h1 id="什么是-WebSocket"><a href="#什么是-WebSocket" class="headerlink" title="什么是 WebSocket"></a>什么是 WebSocket</h1><p>（黑马是马吗？蜗牛是牛吗？啤酒是酒吗？） </p><p>WebSocket 其实是一个位于七层的协议。WebSocket 协议在 2011 年由 IETF 标准化为 RFC 6455，后由 RFC 7936 补充规范。Web IDL 中的 WebSocket API 由 W3C 标准化。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>统一资源定位符（英语：Uniform Resource Locator，缩写：URL；或称统一资源定位器、定位地址、URL地址，俗称网页地址或简称网址）是因特网上标准的资源的地址（Address），如同在网络上的门牌。它最初是由蒂姆·伯纳斯-李发明用来作为万维网的地址，现在它已经被万维网联盟编制为因特网标准RFC 1738。</p><p>统一资源定位符的标准格式如下：</p><pre><code>[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]</code></pre><p>统一资源定位符的完整格式如下：</p><pre><code>[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]</code></pre><p>其中[访问凭证信息]、[端口号]、[查询]、[片段ID]都属于选填项。</p><p>从这里也可以印证出 WebSocket 是一个七层的协议。</p><p>WebSocket 使用 ws 或 wss 的统一资源标志符，类似于 HTTPS。其中 wss 表示使用了 TLS  的 WebSocket。如：</p><pre><code>ws://example.com/wsapiwss://secure.example.com/wsapi</code></pre><h1 id="为什么要-WebSocket"><a href="#为什么要-WebSocket" class="headerlink" title="为什么要 WebSocket"></a>为什么要 WebSocket</h1><p>为了实现更加实时的通信。</p><h2 id="短连接长连接"><a href="#短连接长连接" class="headerlink" title="短连接长连接"></a>短连接长连接</h2><p>长连接是在 HTTP 1.1 之后默认使用的，但实际上是在用 TCP 的长连接短连接。关于长连接短连接的文章有很多，不再赘述。长连接省去了较多的 TCP 握手和关闭的时间。问题就在于如果较多长连接存在的时候，服务器需要采取一些措施来释放资源。</p><h2 id="流（Streaming）"><a href="#流（Streaming）" class="headerlink" title="流（Streaming）"></a>流（Streaming）</h2><p>流常见的有 Iframe Streaming、XHR Streaming、Flash Streaming、Server-Sent Events。</p><p>其主要思想都是从服务器向客户端发送数据。</p><h2 id="上述优缺点"><a href="#上述优缺点" class="headerlink" title="上述优缺点"></a>上述优缺点</h2><p>短连接自然不用讲，每个文件的请求都需要建立一次连接。</p><p>长连接情况下，仍然需要与客户端保持连接，消耗大量资源。</p><p>到了流的方式，服务器往客户端推送，这个方向的流实时性比较好，服务器的请求压力就会减少很多，因为是服务器给用户推送信息，而不是长连接然后轮询。但是依旧是单向的，客户端请求服务器依然还需要一次 HTTP 请求。</p><p>流对浏览器支持要求也比较高。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>websocket 是独立在单个 TCP 连接上进行的全双工通讯，是个有状态的协议。</p><p>当然除此之外，他还有其他等等优点，还能支持二进制帧、扩展协议、部分自定义的子协议、压缩等特性。</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>之前在图森未来实习工作的时候，曾有幸担任几次面试官，我记得有一位不幸的朋友被我问了 WebSocket 是 Socket 吗。</p><p>（他最后居然一本正经地解释给我听不同 socket 的区别，给我整蒙了）</p><p>其实是因为当时我正做相关方面开发，也是想试一试他知不知道相关方面的知识。</p><p>但是后面回过头来看，这个问题不太行，问了没啥意义- -。。。</p><p>不过这都是题外话了</p>]]></content>
    
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 、Python 代码优化及思考</title>
    <link href="undefined2019/08/26/python/"/>
    <url>2019/08/26/python/</url>
    
    <content type="html"><![CDATA[<p>其实在写 Python 代码前，我并没有学过怎么写 Python，实习写了大量 Python 代码的时候也没有系统学习过 Python 这门编程语言。</p><p>但是并不影响我使用他。</p><a id="more"></a><p>不是说我在吹嘘自己，而是这门语言上手起来真的很简单。</p><p>这门语言给我最大的感触就是他简单易上手，但是这个简单往往不是看上去的那样简单。</p><p>Python 是一个解释型语言，程序执行时由解释器来解释执行。</p><p>Python 的类型是动态类型，但是 Python 是强类型语言。</p><p>说点题外话，我之前和高中同学探讨过家教的问题。</p><p>我也思考过自己如果做家教肯定教不了物理（大学物理挂科）化学（高中天天被班主任锤）生物（忘光了），初中 小学数学么勉强教一教。实习的同事说他的女儿报了很多班，又是小提琴班，又是健脑班的。</p><p>我一想我还是比较擅长写程序的，如果我教小学生写 Python 肯定没问题吧。</p><p>教会一个小孩子写 Python，需要多少节课呢？</p><p>一开始我觉得一天就行了，考虑到有些人刚开始接触，一个星期总没问题了吧。</p><p>什么叫做教会，教会的标准是什么？</p><p>我觉得带他们入门就可以了，比如说会写一些简单的爬虫，或者构造一个简单的后台系统。</p><p>这样就会需要教他们一些网络的基本知识了，然后数据库的 CURD 也得会吧。</p><p>这样子算下来，一周时间能教会多少，我的心里就有了一丝疑问。但是我并没有试验过，也不感兴趣。</p><p>我并不是鼓吹计算机网络、操作系统、数据库等等的知识多么多么重要，本文也不探讨这些问题，不会这些不代表会写代码，会这些也不代表写得来代码。会不会写代码与会不会这些基础知识是没有联系的，会不会写代码和能不能写出高质量代码也是不相关的，会不会基础知识与能不能写出高质量代码也不能扯上关系。你的代码质量高不高也不是你说了算的（2333）</p><p>看来教育也是一件令人头疼的事情呢。</p><p>扯了半天，我想回到我想总结的问题上。</p><p>我先简单介绍和整理一下几个相关的概念吧。</p><h2 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h2><p>进程（Process）在教课书上告诉我，进程是程序的一次执行。</p><p>一个进程拥有自己的 text region、data region、stack region。</p><p>在我看来，进程的概念是为了优化 CPU 等计算资源的而产生的。</p><p>进程切换时，CPU 的寄存器等上下文会被切换，所以就需要进程内部存下这个值。</p><p>随着硬件的提升，我们需要在软件层面对硬件进行多路复用，这才导致了进程的出现和操作系统的发展。</p><p>如果说没有进程这个概念，或者说进程不切换，你的双核电脑就只能边听歌边写代码。</p><p>而不能在后台再下载个小电影啥的。显然不是很合理。</p><h2 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程 Thread"></a>线程 Thread</h2><p>假设一个程序的一次运行，即一个进程占用了一个 CPU，完全独占，我需要这个程序去运算 100 次。</p><p>比如说抓取 100 个网页的信息。</p><p>网络请求是很慢的，起码没有 CPU 处理这些数据快，比如说你访问网络环境差的地方的网站，比你渲染这个页面慢多了。</p><p>比如说你烧一百壶水量不等的开水，你可以按照某种顺序一壶一壶烧，烧开，倒水，换一壶；也可以一次性烧 100 壶水，然后谁开了，就把水倒出来。</p><p>显然后面一种情况，绝大多数情况下更快一点。</p><p>线程（Thread）其实就是对进程的一个更小粒度的划分。</p><h2 id="多进程-多线程"><a href="#多进程-多线程" class="headerlink" title="多进程 多线程"></a>多进程 多线程</h2><p>多进程、多线程描述的是，同样的一堆实例干同一件事的情况。</p><p>一台机器跑多个相同脚本是多进程，多台机器跑同一个相同脚本也是多进程。</p><p>因为往往进程与进程之间不存在耦合关系。</p><p>假设进程之间需要沟通，共享一些东西。</p><p>我们推荐使用多线程的方式来进行。</p><p>共享的资源往往能够被直接访问到，因为他们<strong>可以</strong>拥有相同的一些上下文。但是一台电脑的资源是有限的，我们一台电脑不可能有无限多的 CPU ，所以我们常常需要电脑与电脑之间通讯才能达成协作，这个时候又需要多进程和进程间通讯来完成了。</p><p>选择多进程和多线程是一件按需的事情，往往也没有谁好谁不好的问题。</p><p>这之中的关系其实有点像多核 CPU 和 单核 CPU 的类比。</p><p>多核 CPU 可以访问一块内存，而多个单核 CPU （这里需要看成是不同机器）之间需要通过其他方式（网络请求）来达到相同的目的。</p><p>我们可以发现，在硬件条件允许的情况下，根本不用考虑这个问题，但是现实情况就是我们需要通过有限的硬件来优化结果。</p><h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h2><blockquote><p>全局解释器锁（英语：Global Interpreter Lock，缩写 GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。常见的使用 GIL 的解释器有 CPython 与 Ruby MRI。</p></blockquote><p>咋一看 GIL 是会影响性能的。</p><p>然而 Python 并不一定有 GIL，GIL 并不是 Python 的特性，但由于 CPython 是大部分环境下默认的 Python 执行环境，所以一般大家的 Python 都会有 GIL。</p><p>有关 GIL 的资料有很多（企图 抛砖引玉 偷懒）。</p><p>解决方案之一呢，就是使用 multiprocess 替代 thread，但是就会出现之前说到的上下文不同的问题，会导致一些变量无法共享（需要非常痛苦的多线程 code 来解决）。</p><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>JIT 是 Just-in-time compilation 的缩写。</p><p>通常程序有两种方式执行，静态编译和动态解释。</p><p>前者的效率往往比后者要高。</p><p>所以 JIT 技术就大概是将动态解释变成静态编译。</p><p>例如如下代码，其中包含了一些计算，优化起来的效果是比较好的。</p><pre><code class="python">def add(num_a, num_b):    return num_a + num_b</code></pre><p>但是 JIT 往往在 I/O 密集的代码段中的表现就不那么尽如人意了。</p><pre><code class="python">def read_file(file_name):    with open(file_name) as f:        for line in f:            print(line)</code></pre><p>如果你的代码想在不更改任何一行代码的情况下，做一些优化，不妨尝试一下 PyPy。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于正版二三事</title>
    <link href="undefined2019/05/20/pirate/"/>
    <url>2019/05/20/pirate/</url>
    
    <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>在我个人看来，在中国，山寨和盗版似乎是个常态。</p><p>一方面来说，一些软件厂家在华售价定位就不太合理，另一方面来说，能白嫖就白嫖的想法和还不错的山寨产品等等现实原因，让没有收入的学生的我们不得不去选择那些不太妥当的方式。</p><a id="more"></a><p>比如说 Windows 操作系统，在 XP 系统时代，那时候的我才读小学初中，本身就没有啥正版意识，然后在数码商店买到的装机光盘上刻着“三星正版”字样，还画着三颗五角星。</p><p>于是我就买下了番茄花园家做的镜像光盘，学会了重装系统。重装之后还送装好的 Office 套件。之后又接触了深度、雨林木风等等装机的，才恍然大悟。在我的印象中，我看了看当时 Office 套件当时售价高达几千块，比我家那台老电脑售价还高，我总不可能让父母买，毕竟似乎得要几个月工资呢。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>上了高中之后，微软推出了 Win8，当时预览版安装似乎并没有授权这一说，他巴不得让你用用，给他们找找 bug。</p><p>我也是在高中开始接触一些编程，当时也不知道 Linux，只知道 Windows 靠着友好的界面，打下了个人电脑操作系统市场的天下。</p><p>印象最深刻的是，我在高二有幸参加了APOI，比赛环境是 Linux，巨难用，本来就菜了，影响心情然后又影响比赛。</p><p>实在是想不通这玩意儿这么难用怎么还存在在这个世界上。</p><p>从小我就只在腾讯家氪过金，买各种游戏道具，买扣扣会员。杀毒软件？别问，问就是 360。收费的说不定还没有 360 好用对吧？</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>懵懵懂懂就考上了大学。感谢计算机编程给我高中带去了不少色彩，也让我读上了更好的大学。</p><p>当时自主招生，电子科技大学和北京邮电大学都了我降分，一个是物联网国际班，一个是信息安全方向。</p><p>本着<code>我，黑客，打钱</code>的想法我毅然决然投奔去了电子科大。虽然最终我也没能当上黑客，也没能够盗走别人的扣扣号。</p><p>身边的同学出现了用 Mac 的，还有用 Arch 的叶姐姐，让我对自由软件等等有了初步认识吧，感觉至少不是法盲了，2333，</p><p>虽然我还是用盗版偏多，或者是一些正版+未授权数字注册工具。比如说 Photoshop，我不可能去花那么多钱买一个我就玩玩的授权。</p><p>一个是 Windows，我买我笔记本的时候他说是正版，是不是正版我不知道，因为是盗版的情况下，他也是显示是正版，人家微软也不管你是不是正版，但是 Office 的正版检查可能会严格很多。</p><p>VMWare 我也是用的注册码，因为他家卖的时候还要联系销售代表，我估计销售代表会很惊奇的碰到一个傻乎乎的个人去他家问买正版的事情，多半都是企业才会去问的吧。</p><p>四有一次看见 Peter 直播，他的 Codeforces 插件好牛逼，直接一键生成样例测试，还能一键提交。</p><p>好奇心驱使我下载了 IDEA，但是那个插件似乎年久失修，并没有及时更新，网上的教程也很老。</p><p>因为自己也不写 Java，这件事不了了之，IDEA 也被我无情卸载。</p><p>接触过信息学竞赛的选手应该或多或少都知道 Dev-C++ 这个软件吧，当时在高中的时候觉得卧槽，这玩意儿是神器吧。</p><p>然鹅，我大学再次入了 ACM 的坑（果然还是没兴趣也不是那块料），在装了 Ubuntu 之后，用不了 Dev。</p><p>想到叶姐姐曾经和我传教过 Vim，我日这玩意儿更加难用了，我差点把 Ubuntu 卸载了。。。</p><p>叶姐姐见我如此痛苦，给我推荐了 JetBrain 家的编译器，我下载后编译了一题，试了试调试功能，我靠，比 Dev-C++ 还好用，自动补全，一键格式化代码，调试的时候变量自动 watch ，也不会突然把系统弄炸了。</p><p>而且只需要用学生邮箱认证一下就可以用一年了。</p><p>有部分编译器还是社区版的，比如 Android Studio 就是在 IDEA 社区版的基础上做出来的。</p><p>JetBrain 出品，必属精品。 2333</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>在我第一家实习公司实习的时候，操作系统居然可以选 Windows！</p><p>当时我还担心他给我 Mac 我会用不习惯之类的。</p><p>Windows 黑魔法真的多，2333。</p><p>当时需要写 NodeJS 的代码，但是 IDE 找来找去，还是找不到合适的，一开始用了两天 Notepad++，最后 TJT 给我推荐了 WebStorm，JetBrain 再次为我打开了新世界的大门，里面居然还集成了 Git 的功能，可视化 commit，push 啥的，对于我这种新手太友好了。</p><p>后来学习使用阿里家的MapReduce 的时候，阿里提供了一个 IDEA 插件，做的也很棒。</p><p>让我第一次对工具提高效率有了改观。</p><p>但是在 30 天免费试用完之后，JetBrain 提醒我，我该购买了。</p><p>在我网上搜了一堆无效验证码之后，头大了起来。</p><p>然后 TJT 带着笑意告诉了我一个小技巧，也是在他还是学生的时候经常用的，就是在 Google 搜索的时候加上时间限制，就能够搜到最新的能用的注册码了。</p><p>教完我之后，TJT 强调他的是购买的，让我们有能力也支持一下正版。</p><p>不得不说 JetBrain 家的这种做法也还是很成功的。</p><p>试用能够推销产品，不完全封禁注册服务器能够让一部分人还能继续使用，再不行也还有教育邮箱呢。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>后来我工作的时候，我的教育邮箱授权的 Goland 他罢工了，提醒我我的证书由于非法使用被注销了。</p><p>虽然也不是不能用，但是他不断的弹窗让我陷入思考。</p><p>毕竟我现在也是靠这个吃饭的，也稍微有了点的能力。</p><p>我上了 Jetbrain 的商城看了一眼，个人版 249 美刀一年也不算不能接受，但是对于我来说，还是有点肉疼的。</p><p>我仔细看了看，个人版也能进行一般商业用途。我盯着经常弹出的弹框，</p><p>陷入了深深的纠结。在纠结了两三天后，我还是咬咬牙买了一年授权。</p><p>其实买了之后也没有特别的感觉，尤其是没有变强的感觉！</p><p>换个角度来说，JetBrain 也不会因为我用盗版抓着我个人用户不放，我完全可以后者脸皮再用用盗版。</p><p>我甚至给我的同学，一个用 notepad 写代码的“原始程序员”传教了 JetBrain ，现在他也入教了。</p><p>我不仅为他带去了顾客，<del>他不是应该感谢我才对嘛</del>（厚颜无耻）JetBrain 家的产品也越来越多了，现在都可以连数据库，还有专门的软件处理团队协作，进行代码 Review 了。</p><p>同事在我安利完了之后，也说真香。</p><p>事后仔细想想，其实付不付钱都无可厚非，我个人内心里也没有特别大的负罪感，你当然可以站在道德的高处指责我，但是我是无所谓的，我可以拿这一千七百大洋去潇洒，吃几顿好的，给自己买几件衣服，给父母买点东西，或者加点钱买龙狙（龙狙：你是看谁不起？）。</p><p>我买了之后，也不过是给 JetBrain 一点点额外支持罢了。我用他家的产品其实就是最大的支持。</p><p>但是我觉得有可能这是一个比较好的开端？毕竟你支持我支持，也能帮助 JetBrain 开发得更好，最后受益的也是自己。但现在想想还是肉疼呀。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码规范笔记</title>
    <link href="undefined2018/08/07/code-format/"/>
    <url>2018/08/07/code-format/</url>
    
    <content type="html"><![CDATA[<p>有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>非常感谢墨墨科技能给大二的我一个实习机会，是我的第一份工作呢。</p><p>一开始上手的是一份 NodeJS 写成的工程，由于一开始看不懂，拖的时间也比较长，更改代码的时候也只能复制粘贴原来的代码，然后在上面更改。Code Review 的时候被吐槽了一下我的代码习惯。主要是缩进问题，大括号问题和命名风格问题。</p><p>好的代码风格不仅仅是美观，同时也是为了软件的维护性与拓展性。你当然可以不遵守代码风格，这就好比是邋遢一点，别人也不一定能看出来呢。</p><h2 id="一致性原则"><a href="#一致性原则" class="headerlink" title="一致性原则"></a>一致性原则</h2><p>你的代码应该与你所处的环境保持一致，如果你的公司采用 <code>四格空格</code> 缩进，显然你用其他方式都不太好。但是，如果你愿意，你私下的代码可以采用你喜欢的方式，甚至是 <code>七格空格</code> 缩进都行。</p><h2 id="缩进问题"><a href="#缩进问题" class="headerlink" title="缩进问题"></a>缩进问题</h2><p>缩进应该采用空格的方式进行。这在很多 IDE 上都提供了将 Tab 转换为 space 的选项。</p><p>首先 Tab 缩进多少格，完全是由操作系统或者编辑器决定的。不同情况下看到的情况不同。</p><p>其次是根据代码缩进决定 scope 的语言，有时会拒绝你的这个 Tab。</p><p>之前为了图方便，Vim 的 <code>八格缩进</code> 和 <code>空格缩进</code> 结合，到了别人的电脑上，就成了不注意缩进了。</p><p>Google c++ Style Guide 给出的建议是 <code>两格缩进</code>。我在翻阅阿里云的样例程序的时候，也注意到是 <code>两格缩进</code>,这多半也会是他们公司的规范吧。</p><h2 id="大括号问题"><a href="#大括号问题" class="headerlink" title="大括号问题"></a>大括号问题</h2><p>If-statement 后面无论是不是一句话，都应该加上大括号。</p><p>这样做是为了减少隐藏的 Bug。</p><p>同样 While-statement 也应该后面跟上大括号。</p><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><p>我注意到我司是采用类似的驼峰命名法（最前面的小写并不代表类型）。所以我一开始，首字母就大写了，然后被提出批评了。首字母大写往往是给类名使用的，普通变量不应该有。</p><p>在大小写不敏感的情况下，应该采用下划线分离单词。</p><p>然后就是变量名没意义，我上手一个 loop 就开始 <code>int i</code> 这种操作了，被狠狠批评：“不说下次读了，这次我都没看懂。”确实是很不好的习惯呢。</p><h2 id="留白问题"><a href="#留白问题" class="headerlink" title="留白问题"></a>留白问题</h2><p>看到中文文案排版，提到了留白的问题，我回去检查了一下之前的文章，嗯，没有一篇是遵守的。（手改花了好久）</p><p>之前发现在 Word 下写中英文的时候，之间会出现小小的留白，然后感叹了一下 Word 的细节还是很不错的，如果不是麻烦的话，Word 也是可以排版出很漂亮的格式的。</p><p>留白就是在中英文穿插的时候，在中文与英文之间，以人工空格的方式隔开，来达到排版上的美观。</p><h2 id="代码规范参考"><a href="#代码规范参考" class="headerlink" title="代码规范参考"></a>代码规范参考</h2><p>以下列出了一些非常优秀的代码规范参考，在空闲之余，我也会将下面的内容慢慢补充到上面。</p><p><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener" title="Google C++ Style Guide">Google C++ Style Guide</a></p><p><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener" title="中文文案排版指北">中文文案排版指北</a></p><center style="font-size:256%;"> 與大家共勉之。</center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置 Q# 开发环境</title>
    <link href="undefined2018/06/30/qsharp/"/>
    <url>2018/06/30/qsharp/</url>
    
    <content type="html"><![CDATA[<p>Q# 是一门特定领域编程语言，用来表达量子算法。它最初作为量子开发套件的一部分由微软公开发布给公众。</p><a id="more"></a><blockquote><p>Q# (pronounced as Q sharp) is a domain-specific programming language used for expressing quantum algorithms. It was initially released to the public by Microsoft as part of the Quantum Development Kit.</p></blockquote><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/DQ1nXgxUIAEm2V7.jpg" srcset="undefined" alt=""></p><h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><p>这里只给出 Windows 下的安装方法</p><h3 id="安装-Visual-Studio"><a href="#安装-Visual-Studio" class="headerlink" title="安装 Visual Studio"></a>安装 Visual Studio</h3><p>去官网下载 <a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">Visual Studio download page</a> ，我们选择社区版，社区版是免费版本，而其他两个版本提供付费功能。</p><p>安装只需要安装 Visual Studio 的本体和 <strong>.NET Core cross-platform development</strong> 即可，不需要安装其他的开发组件。</p><h3 id="安装-Quantum-Development-Kit"><a href="#安装-Quantum-Development-Kit" class="headerlink" title="安装 Quantum Development Kit"></a>安装 Quantum Development Kit</h3><p>下载并安装 <a href="https://marketplace.visualstudio.com/items?itemName=quantum.DevKit" target="_blank" rel="noopener">Quantum Development Kit</a> </p><h3 id="Clone-repo"><a href="#Clone-repo" class="headerlink" title="Clone repo"></a>Clone repo</h3><p>打开 Visual Studio，在上方菜单栏找到（团队 &gt; 管理连接）(Team &gt; Manage Connections)</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/QQ%E5%9B%BE%E7%89%8720180630114022.png" srcset="undefined" alt=""></p><p>然后会在右侧弹出对话框，选择克隆，输入 <code>https://github.com/Microsoft/Quantum.git</code>，选择克隆的目录，克隆下来。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/QQ%E6%88%AA%E5%9B%BE20180630114040.png" srcset="undefined" alt=""></p><p>克隆完成后，对话框变成了 Solution Explorer，双击打开 QsharpLibraries.sln, 此时就会开始安装依赖项。</p><p>（可选项）要安装用于非商业用途的库，请在 GitHub 上导航到 Microsoft / Quantum-NC。然后克隆存储库并打开 Quantum-NC.sln 解决方案。（此句话机翻 2333）</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/QQ%E6%88%AA%E5%9B%BE20180630115316.png" srcset="undefined" alt=""></p><p>右键 TeleportationSample 这个 project（在 Sample &gt; 0.Introduction内）点击设为启动项目</p><p>然后按 F5 运行。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/QQ%E5%9B%BE%E7%89%8720180630115633.png" srcset="undefined" alt=""></p><p>出现上图代表你已经成功配置好了。</p><h2 id="如何新建一个-Q-程序"><a href="#如何新建一个-Q-程序" class="headerlink" title="如何新建一个 Q# 程序"></a>如何新建一个 Q# 程序</h2><p>文件 &gt; 新建 &gt; 项目</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/qsharp/QQ%E6%88%AA%E5%9B%BE20180630140945.png" srcset="undefined" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&tabs=tabid-vs2017" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/quantum/quantum-installconfig?view=qsharp-preview&amp;tabs=tabid-vs2017</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux 安装指北</title>
    <link href="undefined2018/06/17/arch/"/>
    <url>2018/06/17/arch/</url>
    
    <content type="html"><![CDATA[<p>这是一份 Archlinux 安装指北</p><a id="more"></a><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>从官方网站获取镜像，似乎被墙了？<br><a href="https://www.archlinux.org/" target="_blank" rel="noopener">https://www.archlinux.org/</a></p><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><p>VMware 没有 Arch 的选项，所以我们只能选择 Linux 内核 4.X 更高。</p><p>如果是对实体机安装，则需要其他工具，比如 LinuxLive USB Creator</p><h2 id="选择-Boot-Arch-Linux-x86-64"><a href="#选择-Boot-Arch-Linux-x86-64" class="headerlink" title="选择 Boot Arch Linux (x86_64)"></a>选择 Boot Arch Linux (x86_64)</h2><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/arch/QQ%E6%88%AA%E5%9B%BE20180617073025.png" srcset="undefined" alt=""></p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>查看块设备</p><pre><code class="bash">lsblk</code></pre><p>然后发现是 sda，那么我们直接对 <code>/dev/sda</code> 进行分区</p><pre><code class="bash">fdisk /dev/sda</code></pre><p>按 n 新建分区，根据对应操作即可。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/arch/QQ%E6%88%AA%E5%9B%BE20180617074247.png" srcset="undefined" alt=""></p><h2 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h2><p>如果有其他分区 也需要挂载</p><pre><code class="bash">mkfs.ext4 /dev/sdamount /dev/sda /mnt</code></pre><h2 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h2><pre><code class="bash">pacstrap /mnt base base-devel</code></pre><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><p>生成一个 fstab 文件来规定磁盘分区、块设备，或者远程文件系统是如何挂载进文件系统中的。</p><pre><code class="bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></pre><p>进入 chroot 环境，这样可以为当前进程以及子进程切换当前根目录。</p><pre><code class="bash">arch-chroot /mnt</code></pre><p>设置时间</p><pre><code class="bash">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc --utc</code></pre><p>设置语言</p><pre><code class="bash">nano /etc/locale.gen </code></pre><p>然后将 en_US UTF8 这行注释掉，或者是换成你想要的语言。（推荐英语）</p><pre><code class="bash">locale-genecho LANG=en_US.UTF-8 &gt; /etc/locale.confexport LANG=en_US.UTF-8</code></pre><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><pre><code class="bash">echo &lt;主机名&gt; &gt; /etc/hostname</code></pre><p>接着向 <code>/etc/hosts</code> 文件添加 hosts 条目。</p><pre><code class="text">#&lt;ip-address&gt;    &lt;hostname.domain.org&gt;    &lt;hostname&gt;127.0.0.1    localhost.localdomain    localhost::1        localhost.localdomain    localhost127.0.1.1    &lt;主机名&gt;.localdomain    &lt;主机名&gt;</code></pre><h2 id="设置-root-密码"><a href="#设置-root-密码" class="headerlink" title="设置 root 密码"></a>设置 root 密码</h2><pre><code class="bash">passwd</code></pre><h2 id="安装-GRUB-引导"><a href="#安装-GRUB-引导" class="headerlink" title="安装 GRUB 引导"></a>安装 GRUB 引导</h2><pre><code class="bash">pacman -S grub os-probergrub-install --target=i386-pc /dev/sdX    # sdX 为目标磁盘grub-mkconfig -o /boot/grub/grub.cfg</code></pre><h2 id="快结束辣"><a href="#快结束辣" class="headerlink" title="快结束辣"></a>快结束辣</h2><pre><code class="bash">exit # 回到安装环境umount -R /mntreboot</code></pre><p>到这里，系统其实已经装好啦。</p><h2 id="启动网络"><a href="#启动网络" class="headerlink" title="启动网络"></a>启动网络</h2><pre><code class="bash">ip link</code></pre><p>yournetworkname 在那个方括号前面</p><pre><code class="bash">vi /etc/systemd/network/yournetworkname.network</code></pre><p>添加下述内容</p><pre><code class="text">[Match]name=en*[Network]DHCP=yes</code></pre><pre><code class="bash">systemctl restart systemd-networkdsystemctl enable systemd-networkd</code></pre><p>将下面这两句话加进 /etc/resolv.conf 中</p><pre><code class="text">nameserver 8.8.8.8nameserver 8.8.4.4</code></pre><h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><pre><code class="bash">pacman -S &lt;驱动包&gt;</code></pre><p>官方支持的驱动包：</p><ul><li>通用：xf86-video-vesa</li><li>因特尔系：xf86-video-intel</li><li>AMD/ATI 系：xf86-video-ati</li><li>nVidia 系：<br>  GeForce 400 及更新系列：nvidia<br>  2006 至 2010 年间 GeForce 8000/9000、ION 和 100-300 系列 [NV5x, NV8x, NV9x and NVAx]：nvidia-340xx<br>  2004 至 2006 年间 GeForce 6000/7000 系列 [NV4x and NV6x]：nvidia-304xx</li></ul><h2 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h2><pre><code class="bash">pacman -S xorg xorg-serverpacman -S gnome gnome-extrasystemctl start gdm.servicesystemctl enable gdm.service</code></pre><p>如果 systemctl start gdm.service 死机了 建议重启 qwq</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一种交互式文档——Jupyter 的部署</title>
    <link href="undefined2018/06/16/jupyter/"/>
    <url>2018/06/16/jupyter/</url>
    
    <content type="html"><![CDATA[<p>也许说到 Jupyter 你会觉得陌生，但想必你或多或少听过鼎鼎大名的 IPython。</p><a id="more"></a><p>其实 Jupyter 脱胎于 IPython 项目，IPython 顾名思义，是专注于 Python 的项目，但随着项目发展壮大，已经不仅仅局限于 Python 这一种编程语言了。Jupyter 的名字就很好地释义了这一发展过程，它是 Julia、Python 以及 R 语言的组合，字形相近于木星（Jupiter），而且现在支持的语言也远超这三种了。</p><p>Jupyter 就是这样一个将说明文字、代码、图表、公式、结论都整合在一个文档中的文档工具。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jupyter/widgets.gif" srcset="undefined" alt=""></p><h2 id="Jupyter-的优点"><a href="#Jupyter-的优点" class="headerlink" title="Jupyter 的优点"></a>Jupyter 的优点</h2><ul><li>极其适合数据分析<br>  想象一下如下混乱的场景：你在终端中运行程序，可视化结果却显示在另一个窗口中，包含函数和类的脚本存在其他文档中，更可恶的是你还需另外写一份说明文档来解释程序如何执行以及结果如何。此时 Jupyter Notebook 从天而降，将所有内容收归一处，你是不是顿觉灵台清明，思路更加清晰了呢？</li><li>支持多语言<br>  也许你习惯使用 R 语言来做数据分析，或者是想用学术界常用的 MATLAB 和 Mathematica，这些都不成问题，只要安装相对应的核（kernel）即可。</li><li>分享便捷<br> 支持以网页的形式分享，GitHub 中天然支持 Notebook 展示，也可以通过 nbviewer 分享你的文档。当然也支持导出成 HTML、Markdown 、PDF 等多种格式的文档。</li><li>远程运行<br>  在任何地点都可以通过网络链接远程服务器来实现运算。</li><li>交互式展现<br>  不仅可以输出图片、视频、数学公式，甚至可以呈现一些互动的可视化内容，比如可以缩放的地图或者是可以旋转的三维模型。</li></ul><h2 id="安装-Jupyter"><a href="#安装-Jupyter" class="headerlink" title="安装 Jupyter"></a>安装 Jupyter</h2><p>首先我们先更新一下（可选项）</p><pre><code class="bash">$ apt update$ apt upgrade</code></pre><p>然后安装 pip，用 pip 直接安装 Jupyter</p><pre><code class="bash">$ apt install python3-pip$ pip3 install jupyter</code></pre><h2 id="运行-Jupyter"><a href="#运行-Jupyter" class="headerlink" title="运行 Jupyter"></a>运行 Jupyter</h2><pre><code class="bash">$ jupyter notebook [--allow-root]</code></pre><p>使用上述命令就可以直接启动 jupyter，如果你是 root 用户，需要添加 –allow-root 选项。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jupyter/QQ%E6%88%AA%E5%9B%BE20180616204944.png" srcset="undefined" alt=""></p><p>在本地，你可以直接用 token 访问，就可以直接开始使用啦。（在我的 Ubuntu 上他会自动启动浏览器）</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jupyter/QQ%E6%88%AA%E5%9B%BE20180616204915.png" srcset="undefined" alt=""></p><p>如果你是在 VPS 安装的 Jupyter，则需要映射到公网上，需要添加启动选项 –id=xxx.xxx.xxx.xxx 然后直接用浏览器访问就行了。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jupyter/QQ%E6%88%AA%E5%9B%BE20180616205439.png" srcset="undefined" alt=""></p><h2 id="安装其他语言支持"><a href="#安装其他语言支持" class="headerlink" title="安装其他语言支持"></a>安装其他语言支持</h2><p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p><p>可以参考官方给出的 kernel 列表，根据需求安装自己需要的语言。</p><p>文章开头的图是 C++ 的 Cling 的一个示例</p><h2 id="在线-Jupyter"><a href="#在线-Jupyter" class="headerlink" title="在线 Jupyter"></a>在线 Jupyter</h2><p>除了自己搭建 Jupyter 之外，我们还可以用 Azure notebook</p><p><a href="https://notebooks.azure.com/" target="_blank" rel="noopener">https://notebooks.azure.com/</a></p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/jupyter/QQ%E6%88%AA%E5%9B%BE20180616221105.png" srcset="undefined" alt=""></p><p>这是微软提供的在线jupyter服务，通过 Terminal 我们可以看到大概有 20 G 的存储空间，但是好像只支持 Python、R。</p><p>但是微软添加了其他的功能，你可以一键 clone 别人的供自己研究，也可以从 GitHub 上导入，然后还可以 git pull。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM 输入输出优化技巧——故事的后来</title>
    <link href="undefined2018/06/15/acm-io-optimize-2/"/>
    <url>2018/06/15/acm-io-optimize-2/</url>
    
    <content type="html"><![CDATA[<p>作为一个蒟蒻，整天被各种 ACM 大神吊着打，他们不仅喜欢出难题考到你，甚至连简单题都不让你 AC ——故意出数据卡你。</p><p>比如说构造一个 spfa 过不去的图，或者卡那些不打读入优化的懒家伙。</p><a id="more"></a><p>在很久很久以前，在我还是刚刚学 OI 的时候，学弟（没错，你没有看错，就是学弟！）就教我用 scanf 了。</p><p>“哇，这是什么垃圾，还要记什么占位符”</p><p>直到我看了某白色的竞赛书，居然可以有 cin cout 这种不用记占位符神操作？！</p><p>我靠 ，我就跟发现新大陆了一样，之后一直使用 cin cout 过我的模拟题生活。</p><h2 id="后来的后来"><a href="#后来的后来" class="headerlink" title="后来的后来"></a>后来的后来</h2><p>他们出了一道裸的线段树，然后我读入炒鸡慢，他们把我卡掉了！</p><p>甚至上了大学，还有个不知道菜到哪里去（误）的人嘲笑我，说垃圾 cin 肯定跑不过 scanf。</p><h2 id="直到了今天！"><a href="#直到了今天！" class="headerlink" title="直到了今天！"></a>直到了今天！</h2><p>故事终于发生了转机。</p><p>我想说的是，你们<del>辣鸡</del> scanf 终于跑不过我大 cin 啦，哼哼哼哼~~</p><p>当然是关同步的，不关同步别想了(那份代码 TLE 了。。。)</p><h2 id="测试现场"><a href="#测试现场" class="headerlink" title="测试现场"></a>测试现场</h2><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/acm-io-optimize-2/QQ%E6%88%AA%E5%9B%BE20180615062851.png" srcset="undefined" alt=""></p><h3 id="测试用题目"><a href="#测试用题目" class="headerlink" title="测试用题目"></a>测试用题目</h3><p><a href="http://codeforces.com/contest/984/problem/C" target="_blank" rel="noopener">http://codeforces.com/contest/984/problem/C</a></p><h3 id="测试用代码"><a href="#测试用代码" class="headerlink" title="测试用代码"></a>测试用代码</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll p, q, b;int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    int T;    cin &gt;&gt; T;    while (T--) {        cin &gt;&gt; p &gt;&gt; q &gt;&gt; b;        p %= q;        ll e = __gcd(p, q);        p /= e;        q /= e;        while (b != 1) {            while (q % b == 0) q /= b;            b = gcd(q, b);        }        if (q == 1)            cout &lt;&lt; &quot;Finite\n&quot;;        else            cout &lt;&lt; &quot;Infinite\n&quot;;    }}</code></pre><p>所有测试用代码从本代码的基础上加以修改，或替换读入，或者替换gcd。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th align="center">代码编号</th><th align="center">编译器</th><th align="center">区别</th><th align="center">时间</th></tr></thead><tbody><tr><td align="center">39253502</td><td align="center">GNU C++17</td><td align="center">关同步cin std::gcd</td><td align="center">358 ms</td></tr><tr><td align="center">39253484</td><td align="center">GNU C++17</td><td align="center">按字符读入优化 std::gcd</td><td align="center">499 ms</td></tr><tr><td align="center">39253554</td><td align="center">GNU C++17</td><td align="center">按字符读入优化 std::gcd</td><td align="center">483 ms</td></tr><tr><td align="center">39253582</td><td align="center">GNU C++14</td><td align="center">关同步cin std::__gcd</td><td align="center">358 ms</td></tr><tr><td align="center">39253589</td><td align="center">GNU C++11</td><td align="center">关同步cin std::__gcd</td><td align="center">436 ms</td></tr><tr><td align="center">39253603</td><td align="center">GNU C++98</td><td align="center">关同步cin std::__gcd</td><td align="center">436 ms</td></tr><tr><td align="center">39253617</td><td align="center">GNU C++17</td><td align="center">关同步cin 手写gcd</td><td align="center">389 ms</td></tr><tr><td align="center">39253661</td><td align="center">GNU C++17</td><td align="center">scanf std::gcd</td><td align="center">374 ms</td></tr></tbody></table><p>因为 std::gcd() 是 C++17 有的，所以其他使用了 std::__gcd()</p><p>由于 C++17 测试版本和 C++14 测试版本所耗费时间相同，暂时排除标准 gcd 函数的影响。</p><p>按字符读入优化是你们最喜欢的按字符读入，然后处理成数字返回。其中有两个版本的，39253484是我写的，39253554是 @Xris 写的，两份只是为了证明 <del>我手写的东西比叶姐姐写的常数大</del> 排除影响。</p><p>手写 gcd() 来自 @Xris <a href="http://xr1s.me/" target="_blank" rel="noopener">http://xr1s.me/</a></p><pre><code class="cpp">// Stein&#39;s algorithm, find the greatest common divisor (GCD) of m and n.// The result will always be non-negative.// If m or n is zero, the result will be the bigger one.// This implementation is 1 time faster than GNU STL std::gcd (C++17).// @param m: m above.// @param n: n above.// @return: GCD(m, n), always positive.template &lt;typename T&gt;T gcd(T m, T n) {  if (!m || !n) return m | n;  if (m &lt; 0) m = -m;  if (n &lt; 0) n = -n;  int p = 0;  while (!(m &amp; 1) &amp;&amp; !(n &amp; 1))    m &gt;&gt;= 1, n &gt;&gt;= 1, ++p;  while (n) {    while (!(m &amp; 1)) m &gt;&gt;= 1;    while (!(n &amp; 1)) n &gt;&gt;= 1;    if (m &gt;= n) std::swap(m, n);    n = (n - m) &gt;&gt; 1;  }  return m &lt;&lt; p;}</code></pre><h3 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h3><p>在 C++14 及之后版本的 iostream 明显在时间上占优势。</p><p>手写的 gcd 函数不占有优势（叶姐姐的那个应该会比递归版本的快）</p><h2 id="理性对待测试结果"><a href="#理性对待测试结果" class="headerlink" title="理性对待测试结果"></a>理性对待测试结果</h2><p>测试只是测了一次，但是我觉得应该不会有太大的问题。</p><p>由于参加各类竞赛的时候并不知道具体的编译选项，所以还是推荐使用其他读入方法。但是对于 Codeforces 平台上的题，用关同步的 iostream + C++17 效果更佳。其实前两天我看到某群里就说同一份代码 c++17 没过 c++14 过了。甚是玄学。</p><p>由于 Codeforces 是 Windows 的，我们也不知道跨平台后是不是也是有相同结果。</p><p>根据个人经验，C++98，在 Linux 下读写文件时 fstream 的速度比 stdio 快。在 Windows 下旗鼓相当。</p><h2 id="后来的最后"><a href="#后来的最后" class="headerlink" title="后来的最后"></a>后来的最后</h2><p>本文对所有情况不具有普遍性，但仍具有一定参考价值 =w=</p><p>代码也在 Codeforces 上，可以直接查看，欢迎其他小伙伴加入测试或者讨论。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL 安装指南</title>
    <link href="undefined2018/04/22/wsl/"/>
    <url>2018/04/22/wsl/</url>
    
    <content type="html"><![CDATA[<p>在学习编程的时候，我们可能会学到如何使用 Linux，那简便快捷地建立这样一个环境是挺有必要的。除了用虚拟机安装 Linux 之外，我们可以用 WSL 来解决这样一个问题。</p><a id="more"></a><h2 id="什么是WSL"><a href="#什么是WSL" class="headerlink" title="什么是WSL"></a>什么是WSL</h2><p>Windows Subsystem for Linux（简称 WSL）是一个为在 Windows 10 上能够原生运行 Linux 二进制可执行文件（ELF 格式）的兼容层。它是由微软与 Canonical 公司合作开发，目标是使纯正的 Ubuntu 14.04 “Trusty Tahr” 映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p><p>当然现在的 WSL 支持了更多发行版，可以在商店里看到。</p><h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><h3 id="勾上系统选项"><a href="#勾上系统选项" class="headerlink" title="勾上系统选项"></a>勾上系统选项</h3><p>控制面板 -&gt; 程序和功能 -&gt; 启用或关闭 Windows 功能 -&gt; 勾选 适用于 Linux 的 Windows 子系统</p><p>Control Panel -&gt; Programs -&gt; Programs and Features -&gt; Turn Windows features on or off -&gt; windows Subsystem for Linux</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/813233-20171024162129051-1763340853.png" srcset="undefined" alt=""></p><p>勾选上之后，系统会查找对应组件，然后重启电脑。</p><h3 id="在商店中安装"><a href="#在商店中安装" class="headerlink" title="在商店中安装"></a>在商店中安装</h3><p>我们在商店中搜索 <code>WSL</code></p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422154459.png" srcset="undefined" alt=""></p><p>（什么？你问我怎么打开商店？在任务栏“开始”的右边有个搜索，可以输入 store 或者商店打开）</p><p>点击 get the apps 就会出现</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422154046.png" srcset="undefined" alt=""></p><p>我们可以尝试一下 Ubuntu 。</p><h3 id="初次运行wsl"><a href="#初次运行wsl" class="headerlink" title="初次运行wsl"></a>初次运行wsl</h3><p>按下 win + R，运行 cmd 。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422154619.png" srcset="undefined" alt=""></p><p>在 cmd 中输入命令 <code>bash</code></p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422154808.png" srcset="undefined" alt=""></p><p>或者在开始菜单栏里面找到 Ubuntu 也是可以的。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422155424.png" srcset="undefined" alt=""></p><p>然后根据安装向导就能轻易完成安装辣。</p><h2 id="其他的配置"><a href="#其他的配置" class="headerlink" title="其他的配置"></a>其他的配置</h2><h3 id="WSL中访问本地文件"><a href="#WSL中访问本地文件" class="headerlink" title="WSL中访问本地文件"></a>WSL中访问本地文件</h3><p>在 /mnt 目录下有 c、d、e 等文件夹，分别表示本地的 C 盘、D 盘、E 盘，直接 cd 到相应路径下即可。</p><h3 id="本地访问WSL的根目录"><a href="#本地访问WSL的根目录" class="headerlink" title="本地访问WSL的根目录"></a>本地访问WSL的根目录</h3><p>微软强烈不建议在外部对 WSL 文件系统进行更改，所以未公开 WSL 所在的根目录。（但是还是可以找到的。）</p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422155824.png" srcset="undefined" alt=""></p><p>在窗体上右键，选择 Properties 选项，就可以更改字体和字体大小</p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422160123.png" srcset="undefined" alt=""></p><p>可以看到自带了一些工具 <code>git</code>、<code>ssh</code>，当然如果没有对应的工具的话，我们还可以尝试用包管理器，使用 <code>apt</code> 来安装想要的工具。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/wsl/QQ%E6%88%AA%E5%9B%BE20180422160407.png" srcset="undefined" alt=""></p><h3 id="安装图形界面"><a href="#安装图形界面" class="headerlink" title="安装图形界面"></a>安装图形界面</h3><p>安装图形界面的方法略麻烦，想要详细了解的可以点这里 <a href="https://www.jianshu.com/p/aca81f8c7f08" target="_blank" rel="noopener">https://www.jianshu.com/p/aca81f8c7f08</a></p><h2 id="其他的发行版"><a href="#其他的发行版" class="headerlink" title="其他的发行版"></a>其他的发行版</h2><p>当然，我们还可以安装一些其他发行版的 Linux，当然这可能需要我们自己摸索，或者使用搜索引擎来帮助我们</p><p><a href="https://www.cnblogs.com/wurui1994/p/7839777.html" target="_blank" rel="noopener" title="ArchLinux的WSL安装">ArchLinux的WSL安装</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>为了写这篇，我在我的 win 10 上装了个 win 10 虚拟机，然后再装了 WSL。。。。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探正则表达式</title>
    <link href="undefined2018/04/17/regex/"/>
    <url>2018/04/17/regex/</url>
    
    <content type="html"><![CDATA[<p>后来的后来，在 Tusimple，天天被抓去写正则。。。</p><a id="more"></a><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><p>引用百科的话：</p><blockquote><p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE），又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。</p></blockquote><p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成regex，单数有regexp、regex，复数有regexps、regexes、regexen。</p><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener" title="百科链接">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p><h2 id="什么时候使用正则表达式"><a href="#什么时候使用正则表达式" class="headerlink" title="什么时候使用正则表达式"></a>什么时候使用正则表达式</h2><p>在有以下需求的时候使用</p><ul><li>从文本中找到我们想要的内容。</li><li>检测一段文本是否符合设定好的规则</li></ul><h2 id="为什么使用正则表达式"><a href="#为什么使用正则表达式" class="headerlink" title="为什么使用正则表达式"></a>为什么使用正则表达式</h2><p>正则表达式的本质是一个工具，好的工具能简化我们的思维复杂度和编程复杂度。</p><p>使用正则表达式完全是为了简化我们的代码，而不是为了炫技 :D</p><h2 id="如何使用正则表达式"><a href="#如何使用正则表达式" class="headerlink" title="如何使用正则表达式"></a>如何使用正则表达式</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>例如我们想要修改某个配置文件，配置参数为“啥 post 啥 size”的</p><p>我们用 Vim 打开配置文件，输入</p><pre><code>/\w*size\w*</code></pre><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/regex/1.png" srcset="undefined" alt=""></p><p>然后回车，按 N 查找下一个，就能很快找到那一行了，原来我们要找的是 post_max_size。</p><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/regex/2.png" srcset="undefined" alt=""></p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>检测上传的文件的文件名</p><p>我们想要 jpg，png，gif</p><pre><code>img0912.jpgupdated_img0912.pngfavicon.gif</code></pre><p>所以以下文件名应该被过滤</p><pre><code>.bash_profileworkspace.docdocumentation.htmlimg0912.jpg.tmpaccess.lock</code></pre><p><img src="https://edgsheryl.oss-cn-hangzhou.aliyuncs.com/regex/3.png" srcset="undefined" alt=""></p><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>正则表达式被很多编程语言支持，在 C++ 中也不例外，看一个改编自《c++ primer》的示例</p><pre><code>```c++#include &lt;bits/stdc++.h&gt;int main(){    std::string s(&quot;[[:alpha:]]*[^c]ei[[:alpha:]]*&quot;);    std::regex r(s);    std::smatch m;    std::string d(&quot;receipt freind theif receive&quot;);    if (std::regex_search(d,m,r))        std::cout&lt;&lt;m.str()&lt;&lt;std::endl;}//output: freind```</code></pre><h2 id="如何学习使用正则表达式"><a href="#如何学习使用正则表达式" class="headerlink" title="如何学习使用正则表达式"></a>如何学习使用正则表达式</h2><p>学习正则表达式的最好方法是实践，所以这里推荐一些网站和工具。</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a> in JavaScript, Python, PCRE 16-bit, generates explanation of pattern</p><p><a href="https://www.debuggex.com/" target="_blank" rel="noopener">https://www.debuggex.com/</a> 正则验证测试，清晰明了</p><p><a href="https://mengzhuo.org/regex/" target="_blank" rel="noopener">https://mengzhuo.org/regex/</a> 中文版正则验证测试</p><p><a href="http://refiddle.com/" target="_blank" rel="noopener">http://refiddle.com/</a> 测试工具</p><p><a href="http://myregexp.com/" target="_blank" rel="noopener">http://myregexp.com/</a> 也是测试工具，都可以试一试</p><p><a href="http://regex.alf.nu" target="_blank" rel="noopener">http://regex.alf.nu</a> 闯关模式练习正则表达式，完成一个个正则匹配的测验</p><p><a href="http://regexone.com/" target="_blank" rel="noopener">http://regexone.com/</a> 通过实际练习掌握正则表达式</p><p><a href="https://regexcrossword.com/" target="_blank" rel="noopener">https://regexcrossword.com/</a> 正则挑战，有不同难度，很丰富</p><p><a href="http://callumacrae.github.io/regex-tuesday/" target="_blank" rel="noopener">http://callumacrae.github.io/regex-tuesday/</a> 正则挑战，完成正则匹配要求</p><p><a href="https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx</a> MSDN 微软出品</p><p>当然学习资料不只有这些，需要善用搜索引擎来发现。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>这篇被我拿去当了公众号推送，感觉自己都不会说话了，我惊奇的发现原来微信公众号是富文本格式的。</p><p>上面的闯关测验还是不错的，感觉自己学到了不少=w=</p>]]></content>
    
    
    
    <tags>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DES 算法学习笔记</title>
    <link href="undefined2018/03/18/des/"/>
    <url>2018/03/18/des/</url>
    
    <content type="html"><![CDATA[<p>DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，</p><a id="more"></a><p>1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DEA），已与作为标准的DES区分开来。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>算法流程可以参考百度百科的算法流程图</p><p><a href="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bf7cb45b367adab429dd1311eabdd879/adaf2edda3cc7cd9ca7533aa3901213fb80e916c.jpg" target="_blank" rel="noopener"><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=bf7cb45b367adab429dd1311eabdd879/adaf2edda3cc7cd9ca7533aa3901213fb80e916c.jpg" srcset="undefined" alt=""></a></p><h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>DES算法在《图解密码技术》这本书上一笔带过了，比较好奇书上说的 f() 函数是什么，于是就找了 DES 的源码来看。</p><p>DES算法有三个参数：data，key，mode。</p><ul><li>data 要加密的信息</li><li>key  加密的密钥</li><li>mode 加密还是解密</li></ul><p>DES算法还使用到了很多置换，搞清楚置换表的作用是非常重要的。</p><p>我们通过 key 置换，循环左移的操作得到 subkey，记为 k1，k2，…，kn。</p><p>首先将 data 置换，并且平分成两半，记为 L0 和 R0。</p><p>第 N 次操作的时候，我们需要将 Ln = R(n-1)，而 Rn = f(L(n-1), R(n-1), kn) 三个参数去计算，计算过程也相当复杂。</p><p>首先我们需要将 R(n-1) 通过拓展表拓展成 48 位的，然后跟 subkey 进行异或，然后根据 s 盒表的规则，将对应每 6 位变换成 4 位，重新变成 32 位，再和 L(n-1) 进行异或操作。</p><p>最最重要的是！千万不能搞错谁和谁异或，用谁去操作，不然 bug 就找不到了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>最后恬不知耻地贴上自己的代码 诶嘿</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;class DES {private://const table    const char IP_Table[64] = {            58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,            62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,            57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,            61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7    };    const char IPR_Table[64] = {            40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31,            38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,            36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,            34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25    };    const char PC1_Table[56] = {            57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,            10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,            63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,            14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4    };    const char PC2_Table[48] = {            14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,            23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,            41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,            44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32    };    const char LOOP_Table[16] = {            1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1    };    const char E_Table[48] = {            32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,            8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,            16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,            24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1    };    const char S_Box[8][4][16] = {            // S1            14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,            0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,            4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,            15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13,            // S2            15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,            3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,            0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,            13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9,            // S3            10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,            13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,            13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,            1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12,            // S4            7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,            13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,            10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,            3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14,            // S5            2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,            14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,            4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,            11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3,            // S6            12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,            10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,            9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,            4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13,            // S7            4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,            13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,            1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,            6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12,            // S8            13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,            1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,            7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,            2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11    };    const char P_Table[32] = {            16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,            2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25    };    int l[20][40], r[20][40];    int keyl[40], keyr[40];    int key[20][70];    int ext[50];public:    DES() {}    ~DES() {}    void crypt(int *data, int *key, int *ret, int mode = 0) {        for (int i = 0; i &lt;= 64; i++) ret[i] = 0;        if (!mode) { //encrypt            memset(l, 0, sizeof l);            memset(r, 0, sizeof r);//initialize the L0,R0            for (int i = 1; i &lt;= 32; i++) {                l[0][i] = data[IP_Table[i - 1]];            }            for (int i = 33; i &lt;= 64; i++) {                r[0][i - 32] = data[IP_Table[i - 1]];            }//initialize the subkey            for (int i = 1; i &lt;= 28; i++) {                keyl[i] = key[PC1_Table[i - 1]];            }            for (int i = 29; i &lt;= 56; i++) {                keyr[i - 28] = key[PC1_Table[i - 1]];            }            for (int i = 1; i &lt;= 16; i++) {                for (int o = 1; o &lt;= LOOP_Table[i]; o++) {                    for (int j = 1; j &lt; 28; j++) {                        keyl[j] = keyl[j + 1];                    }                    keyl[28] = keyl[1];                    for (int j = 1; j &lt; 28; j++) {                        keyr[j] = keyr[j + 1];                    }                    keyr[28] = keyr[1];                }                for (int o = 1; o &lt;= 48; o++) {                    this-&gt;key[i][o] = (PC2_Table[o - 1] &lt;= 28 ? keyl[PC2_Table[o - 1]] : keyr[PC2_Table[o - 1] - 28]);                }            }// Feistal network            for (int i = 1; i &lt;= 16; i++) {                for (int o = 1; o &lt;= 48; o++) ext[o] = r[i - 1][E_Table[o - 1]]; //extend the R(n-1)                for (int o = 1; o &lt;= 48; o++) ext[o] ^= this-&gt;key[i][o];//xor the subkey                for (int o = 0; o &lt; 8; o++) { //core algorithm of f()                    int row = ext[6 * o + 1] * 2 + ext[6 * o + 6];                    int col = ext[6 * o + 2] * 8 + ext[6 * o + 3] * 4 + ext[6 * o + 4] * 2 + ext[6 * o + 5];                    int midresult = S_Box[o][row][col];                    for (int j = 1; j &lt;= 4; j++) {                        ext[32 - 6 * o - j + 1] = midresult % 2;                        midresult /= 2;                    }                }                for (int o = 1; o &lt;= 32; o++) {                    r[i][o] = ext[P_Table[o - 1]] ^ l[i - 1][o];//xor the L(n-1)                }                for (int o = 1; o &lt;= 32; o++) {                    l[i][o] = r[i - 1][o];                }            }            for (int i = 1; i &lt;= 64; i++) {                ret[i] = IPR_Table[i - 1] &lt;= 32 ? r[16][IPR_Table[i - 1]] : l[16][IPR_Table[i - 1] - 32];            }        } else { //decrypt            memset(l, 0, sizeof l);            memset(r, 0, sizeof r);            for (int i = 1; i &lt;= 32; i++) {                l[0][i] = data[IP_Table[i - 1]];            }            for (int i = 33; i &lt;= 64; i++) {                r[0][i - 32] = data[IP_Table[i - 1]];            }            for (int i = 1; i &lt;= 28; i++) {                keyl[i] = key[PC1_Table[i - 1]];            }            for (int i = 29; i &lt;= 56; i++) {                keyr[i - 28] = key[PC1_Table[i - 1]];            }            for (int i = 1; i &lt;= 16; i++) {                for (int o = 1; o &lt;= LOOP_Table[i]; o++) {                    for (int j = 1; j &lt; 28; j++) {                        keyl[j] = keyl[j + 1];                    }                    keyl[28] = keyl[1];                    for (int j = 1; j &lt; 28; j++) {                        keyr[j] = keyr[j + 1];                    }                    keyr[28] = keyr[1];                }                for (int o = 1; o &lt;= 48; o++) {                    this-&gt;key[i][o] = (PC2_Table[o - 1] &lt;= 28 ? keyl[PC2_Table[o - 1]] : keyr[PC2_Table[o - 1] - 28]);                }            }            for (int i = 1; i &lt;= 16; i++) {                for (int o = 1; o &lt;= 48; o++) ext[o] = r[i - 1][E_Table[o - 1]];                for (int o = 1; o &lt;= 48; o++) ext[o] ^= this-&gt;key[17 - i][o];                for (int o = 0; o &lt; 8; o++) {                    int row = ext[6 * o + 1] * 2 + ext[6 * o + 6];                    int col = ext[6 * o + 2] * 8 + ext[6 * o + 3] * 4 + ext[6 * o + 4] * 2 + ext[6 * o + 5];                    int midresult = S_Box[o][row][col];                    for (int j = 1; j &lt;= 4; j++) {                        ext[32 - 6 * o - j + 1] = midresult % 2;                        midresult /= 2;                    }                }                for (int o = 1; o &lt;= 32; o++) {                    r[i][o] = ext[P_Table[o - 1]] ^ l[i - 1][o];                }                for (int o = 1; o &lt;= 32; o++) {                    l[i][o] = r[i - 1][o];                }            }            for (int i = 1; i &lt;= 64; i++) {                ret[i] = IPR_Table[i - 1] &lt;= 32 ? r[16][IPR_Table[i - 1]] : l[16][IPR_Table[i - 1] - 32];            }        }        return;    }};int main() { //take a test    DES des = *(new DES());    int a[100]{};    for (int i = 1; i &lt;= 64; i+=2) a[i] = 1;    int b[100]{};    int c[100]{};    int d[100]{};    des.crypt(a, b, c, 0);    des.crypt(c, b, d, 1);    for (int i = 1; i &lt;= 64; i++) cout &lt;&lt; d[i];}</code></pre><h2 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h2><p>在 1999 年的 DES Challenge III 中，破译 DES 密文只用了 22 小时 15 分钟，所以提出了三重 DES(triple-DES)。</p><p>三重 DES 并不是运行三次 DES 加密，而是加密解密加密的形式</p><p>虽然听上去非常不可思议，但是这样做可以兼容普通的 DES（三次都使用同一个 key）。</p><p>我们称使用两个 key 的 TDEA 为 DES-EDE2，使用三个 key 的为 DES-EDE3。</p><p>对应的，解密过程为：解密加密解密。</p>]]></content>
    
    
    
    <tags>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七周七语言——Ruby 篇</title>
    <link href="undefined2018/02/09/ruby/"/>
    <url>2018/02/09/ruby/</url>
    
    <content type="html"><![CDATA[<p>松本行弘（Yukihiro Matsumoto）大约在1993年发明了Ruby，</p><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="Ruby简史"><a href="#Ruby简史" class="headerlink" title="Ruby简史"></a>Ruby简史</h3><blockquote><p>松本行弘（Yukihiro Matsumoto）大约在1993年发明了Ruby，大家多称他为Matz。从语言的角度看，Ruby出身于所谓的脚本语言家族，是一种解释型、面向对象、动态类型的语言。解释型， 意味着Ruby代码由解释器而非编译器执行。动态类型，意味着类型在运行时而非编译时绑定。从 这两方面看，Ruby采取的策略是在灵活性和运行时安全之间寻找平衡点，我们稍后还会深入讨论 这一点。面向对象，意味着Ruby支持封装（把数据和行为一起打包）、类继承（用一棵类树来组 织对象类型）、多态（对象可表现为多种形式）等特性。Ruby多年来一直默默蛰伏，只为等待一 个恰当的出现时机。终于，随着Rails框架崭露头角，Ruby也在2006年前后一鸣惊人。在企业开 发的丛林中跋涉了十年之后，Ruby指引人们重新找回了编程乐趣。尽管从执行速度上说，Ruby 谈不上有多高效，但它却能让程序员的编程效率大幅提高。——《7周7语言:理解多种编程范型》 [美]Bruce A. Tate</p></blockquote><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>[<a href="http://www.ruby-lang.org" target="_blank" rel="noopener">http://www.ruby-lang.org</a> ][1] 是 Ruby 的官方网站。</p><p>（有意思的是，松本行弘前辈似乎认为他开创了一个有趣的先例：/<em>lang.</em>/g，以至于后来的语言官网格式会参考他，例如 golang.org）</p><p>根据官网的提示应该很快能搭建起环境，目前最新版似乎是 v3.5.0，而我的机子上是 v3.3.3，之前在服务器上使用 Jekyll 工具的时候似乎使用了更早的 Ruby 版本，所以可以看需求安装对应版本。</p><p>安装好可以使用 <code>ruby -v</code> 命令查看安装好的 Ruby 版本，或者输入 irb 启动 Ruby 解释器，验证 Ruby 是否正确安装。</p><h3 id="第一天内容总结"><a href="#第一天内容总结" class="headerlink" title="第一天内容总结"></a>第一天内容总结</h3><p>Ruby 的特点：</p><ul><li>Ruby 是几乎是解释执行的，但是也有开发者正在开发虚拟机，想把 Ruby 代码编译成字节码再执行。</li><li>Ruby 的变量是不需要事先声明的。Ruby 的类型是鸭子类型。</li><li>Ruby 是一门纯面向对象的语言。</li><li>大量的语法糖（Syntactic Sugar）</li></ul><p>好吧 我现在觉得《7周7语言》这本书讲的太笼统了，感觉没看到啥第一天的讲述内容就结束了 QwQ。。。</p><p>Ruby 的设计初衷，似乎目标是作为脚本语言，所以解释执行这一设定非常自然（与 Python，Perl，Bash 相比较）。</p><p>Ruby 的类型采用鸭子类型设计：他只要可以像鸭子一样走路，像鸭子一样叫，那他就是鸭子。</p><p>面向对象部分没有深入了解，但是所有类型都是对象。</p><p><strong>大量的语法糖</strong>。Ruby的语法确实花里胡哨！这根本原因是Ruby的设计者松本行弘前辈认为人适应机器是本末倒置的行为，所以他从机器适应人的角度来设计语法规则，同时他认为执行效率问题不是最大的问题，所以语法糖而且是大量的语法糖应运而生。</p><pre><code class="Ruby">&gt; print &quot;Hello, Ruby&quot;Hello, Ruby=&gt; nil&gt; puts &quot;Hello, Ruby&quot;Hello, Ruby=&gt; nil&gt; p &quot;Hello, Ruby&quot;&quot;Hello, Ruby&quot;=&gt; &quot;Hello, Ruby&quot;</code></pre><p>从上述例子可以看出不同的打印字符串的方法，结果不尽相同，而且我们可以注意到 Ruby 的解释执行是有返回类型的。</p><p>程序分支控制上，除了 if，还有 unless（if 的否定，虽然从翻译上很容易弄混）。不仅如此，还可以 if 后置，例如</p><pre><code class="Ruby">&gt; x = 4=&gt; 4&gt; puts &quot;this statement is True&quot; if x == 4this statement is True=&gt; nil&gt; puts &quot;this statement is False&quot; unless x == 5this statement is False=&gt; nil</code></pre><p>循环控制也如此。</p><pre><code class="Ruby">&gt; x = 1=&gt; 1&gt; x = x + 1 while x &lt; 10=&gt; nil&gt; x=&gt; 10</code></pre><p>似乎我也没写过多少 Ruby 程序，仅仅只能分享一些自认为有趣的东西。</p><h3 id="自习部分"><a href="#自习部分" class="headerlink" title="自习部分"></a>自习部分</h3><p>其实七周七语言这本书真的偷懒——让你自己去查其他资料！</p><p>找：</p><ul><li>✔ Ruby API文档： [<a href="http://ruby-doc.org/][2]" target="_blank" rel="noopener">http://ruby-doc.org/][2]</a></li><li>✔ Programming Ruby ：The Pragmatic Programmer’s Guide [TFH08]的免费在线版本。[传送门][3]</li><li>✔ 替换字符串某一部分的方法。[搬运传送门][4]</li><li>✔ 有关Ruby正则表达式的资料。[搬运传送门][5]</li><li>✔ 有关Ruby区间（range）的资料。[搬运传送门][6]</li></ul><p>做：</p><ul><li>✔ 打印字符串”Hello, world.”。</li><li>✖ 在字符串”Hello, Ruby.”中，找出”Ruby.”所在下标。</li><li>✖ 打印你的名字十遍。</li><li>✖ 打印字符串”This is sentence number 1.”，其中的数字1会一直变化到10。</li><li>✖ 从文件运行Ruby程序。</li><li>✖ 加分题：如果你感觉意犹未尽，还可以写一个选随机数的程序。该程序让玩家猜随机数 是多少，并告诉玩家是猜大了还是猜小了。</li></ul><p>Well, 其实编程提升最快的方法是多敲代码，但是上述任务似乎有些（太简单了）。。</p><p>（逃）</p><hr><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>Day 2 的内容似乎也很杂，这本书不适合系统的学习一门语言，但是时候作为开拓读物之类的。。。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与 Python 函数的定义相似</p><pre><code class="Ruby">def tell_the_truth    trueend</code></pre><p>Ruby 设定函数结束前处理的最后一句话的返回值，作为函数的返回值。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code class="Ruby">&gt; animals = [&#39;lion&#39;,&#39;tiger&#39;,&#39;bear&#39;]=&gt; [&quot;lion&quot;, &quot;tiger&quot;, &quot;bear&quot;]&gt; animals[0]=&gt; &quot;lion&quot;&gt; animals[1]=&gt; &quot;tiger&quot;&gt; animals[2]=&gt; &quot;bear&quot;&gt; animals[3]=&gt; nil&gt; animals[-1]=&gt; &quot;bear&quot;&gt; animals[-2]=&gt; &quot;tiger&quot;&gt; animals[-3]=&gt; &quot;lion&quot;&gt; animals[-4]=&gt; nil&gt; animals[9]  = &#39;cat&#39;=&gt; &quot;cat&quot;&gt; animals=&gt; [&quot;lion&quot;, &quot;tiger&quot;, &quot;bear&quot;, nil, nil, nil, nil, nil, nil, &quot;cat&quot;]</code></pre><p>Ruby 的数组长得也与 Python 相似。。。下标从 0 开始，超出数组长度则返回 nil，有趣的事情是，Ruby 有倒数（从后往前数）这个设定，例子中倒数第一个是 bear，倒数第三个是 lion，而没有倒数第四个。</p><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><pre><code class="Ruby">&gt;  {:array =&gt; [1,2,3],:string =&gt; &quot;string!&quot;}=&gt; {:array=&gt;[1, 2, 3], :string=&gt;&quot;string!&quot;}&gt; things[[1,2,3]]=&gt; nil&gt; things[&quot;qwer&quot;]=&gt; nil&gt; things[:string]=&gt; &quot;string!&quot;</code></pre><p>map</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>一段代码可以作为一个整体来传递！</p><pre><code class="Ruby">&gt; 3.times {p &quot;Hello&quot;}&quot;Hello&quot;&quot;Hello&quot;&quot;Hello&quot;=&gt; 3 class Fixnum            def my_times                i = self                    while i&gt;0                       i = i - 1                        yield                       end                     end                  end                 &gt; 3.my_times{p &quot;Hello&quot;}&quot;Hello&quot;&quot;Hello&quot;&quot;Hello&quot;=&gt; nil</code></pre><p>原理大概就是酱紫 （最后函数应该 return self，与 Ruby 设计保持一致）</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Ruby 的类感觉并不能一两句话就说完，详细了解：[传送门][7]</p><p>Ruby 似乎不能多重继承（例如棱形继承），Java 采用接口来解决这个问题，而 Ruby 采用 Module 来解决。我们对一个类可以进行一个系列的动作的时候，只要 include 对应的模块就行了，该行为称为 Mix in。</p><p>Ruby 太实用了！</p><h3 id="自习"><a href="#自习" class="headerlink" title="自习"></a>自习</h3><p>查</p><ul><li>✖ 分别找到用代码块和不用代码块读取文件的方法，用代码块有什么好处？ </li><li>✔ 如何把散列表转换成数组？数组能转换成散列表吗？ <pre><code>散列表是一个映射，如果只储存value，则可以Hash.each {|i,o| Array.push(o)}数组当然可以转换成散列，对应的是数组下标映射到数组里的值。</code></pre></li><li>✔ 你能循环遍历散列表吗？ <pre><code>  感觉从理论上来说可行  def my_each(&amp;block)      while true          self.each {|i,v| block.call}      end  end  但是为啥代码跑不通。。。  或者我们把每对单独提出来做一个新的散列表，用数组储存他们，然后对数组进行循环遍历。</code></pre></li><li>✔ Ruby的数组能当作栈来用，它还能用作哪些常用的数据结构？<pre><code>  队列  大根堆小根堆（二叉树）</code></pre></li></ul><p>做</p><ul><li>✖ 有一个数组，包含16个数字。仅用each方法打印数组中的内容，一次打印4个数字。然后， 用可枚举模块的each_slice方法重做一遍。</li><li>✔ 我们前面实现了一个有趣的树类Tree，但它不具有简洁的用户接口，来设置一棵新树， 为它写一个初始化方法，接受散列表和数组嵌套的结构。写好之后，你可以这样设置新 树：{‘grandpa’ =&gt; { ‘dad’ =&gt; {‘child 1’ =&gt; {}, ‘child 2’ =&gt; {} }, ‘uncle’ =&gt; {‘child 3’ =&gt; {}, ‘child 4’ =&gt; {} } } }。</li></ul><pre><code class="Ruby">class Tree     attr_accessor :name, :children    def initialize(name,t=[])         if (name.class == Hash)            name.each {|n,v| setdata(n,v)}        else            @name = name            @children = Array.new(0)            t.each {|n,v| @children.push(Tree.new(n,v)) }        end    end    def setdata(name,children=[])        @name = name        @children = Array.new(0)        children.each {|n,v| @children.push(Tree.new(n,v)) }    end    def visitall(n)        for i in (1..n)             print(&quot;\t&quot;)        end        p name        children.each {|i| i.visitall(n+1)}    endendmytree = Tree.new({&#39;grandpa&#39;=&gt; { &#39;dad&#39; =&gt; {&#39;child 1&#39; =&gt; {}, &#39;child 2&#39; =&gt; {} }, &#39;uncle&#39; =&gt; {&#39;child 3&#39; =&gt; {}, &#39;child 4&#39; =&gt; {} } } })mytree.visitall(0)=begin    迭代的方式生成=end</code></pre><ul><li>✖ 写一个简单的grep程序，把文件中出现某词组的行全都打印出来。这需要使用简单的正则 表达式匹配，并从文件中读取各行。（这在Ruby中超乎想象地简单。）如果你愿意的话， 还可以加上行号。</li></ul><hr><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h3><h4 id="开放类"><a href="#开放类" class="headerlink" title="开放类"></a>开放类</h4><pre><code class="Ruby">class NilClass    def blank?        true    endendclass String     def blank?        self.size == 0    endend[&quot;&quot;,&quot;blank&quot;,NIL].each do |element|    puts element unless element.blank?end</code></pre><p>事实上我们在这里并不是新建了两个新的类，而是在原有的类的基础上加了些东西。如果你愿意，甚至可以把它玩坏。</p><h4 id="method-missing"><a href="#method-missing" class="headerlink" title="method_missing"></a>method_missing</h4><p>Ruby 在找不到某种方法的时候，例如你操作的对象不是你想像的那个类型，Ruby 会显示诊断信息，使得 Ruby 更加易于调试。而如果我们覆盖了 method_missing 方法的话，我们可以更改返回值或者行为。</p><p>借用书上的例子（改）：</p><pre><code class="Ruby">class Roman    def self.method_missing name, *args        roman = name.to_s        (roman.count(&quot;I&quot;) +         roman.count(&quot;V&quot;) * 5 +         roman.count(&quot;X&quot;) * 10 +         roman.count(&quot;L&quot;) * 50 +         roman.count(&quot;C&quot;) * 100 )    endend        </code></pre><p>非常巧妙的一个演示，尽管有些不对（跟计数法的计算方法有偏差）。</p><h2 id="语言总结"><a href="#语言总结" class="headerlink" title="语言总结"></a>语言总结</h2><p>我认为书上的语言足够简介：</p><blockquote><p>Ruby 的纯面向对象可以让你用一致的方式来处理对象。鸭子类型根据对象可提供的方法，而<br>不是对象的继承层次，实现了更切合实际的多态设计。Ruby的模块和开放类，使程序员能把行为 紧密结合到语法上，这大大超越了类中定义的传统方法和实例变量。</p></blockquote><p>而不足之处在于：</p><ul><li><p>性能问题<br>  但是我们很高兴看到 Ruby 效率越来越高了，设计者本人也认为效率问题会因为计算机计算速度变快而从另一个角度解决效率问题。</p></li><li><p>并发问题<br>  事实上一直不理解书上这段话。</p></li><li><p>类型安全<br>  无法进行编译的时候的检查，事实上在做第二天自习的时候就遇到了这个问题：构造函数被直接覆盖，而不是重载，而之后需要传入两个参数但我只传入一个参数，没有任何错误提示。</p></li></ul><p>总之，很欣赏 Ruby 的设计哲学。我相信会有越来越多的人了解 Ruby，接受 Ruby 并使用 Ruby。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><pre><code>http://www.ruby-lang.orghttp://ruby-doc.org/http://ruby-doc.com/docs/ProgrammingRuby/http://www.runoob.com/ruby/ruby-string.htmlhttp://www.runoob.com/ruby/ruby-regular-expressions.htmlhttp://www.runoob.com/ruby/ruby-range.htmlhttp://www.runoob.com/ruby/ruby-object-oriented.html</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Steam 挂卡工具 ASF 的 Ubuntu 部署</title>
    <link href="undefined2017/12/25/steam-asf/"/>
    <url>2017/12/25/steam-asf/</url>
    
    <content type="html"><![CDATA[<p>在室(jin)友(qian)的诱惑下，好想要 NEKOPARA 的背景啊 QAQ</p><a id="more"></a><p>就跑去弄了一个 ASF 这么一个神奇的云挂卡工具</p><p>因为最近社区被封了，然后你需要特殊的上网技巧。</p><h2 id="ASF入门"><a href="#ASF入门" class="headerlink" title="ASF入门"></a>ASF入门</h2><p>ASF 3.0 传送门：<a href="https://github.com/JustArchi/ArchiSteamFarm/releases/" target="_blank" rel="noopener">https://github.com/JustArchi/ArchiSteamFarm/releases/</a></p><p>现在市面上的资料绝大多数是 2.0 版本的，但是好像也能用。</p><p>首先我们拿 Windows 来举例子。下载后解压，几个关键的文件是</p><pre><code>├── config│   ├── ASF.json│   ├── ASF.db│   ├── Bot1.json│   ├── Bot1.db│   ├── Bot1.bin│   ├── Bot2.json│   ├── Bot2.db│   ├── Bot2.bin│   └── ...├── ArchiSteamFarm.exe└── ConfigGenerator.html</code></pre><p>其中 ConfigGenerator.html 是拿来生成 .json 的配置文件的，也可以用<a href="https://justarchi.github.io/ArchiSteamFarm/#/bot" target="_blank" rel="noopener">https://justarchi.github.io/ArchiSteamFarm/#/bot</a></p><p>把生成的配置文件放在 config 文件下，然后双击 ArchiSteamFarm.exe 即可 <del>喊666</del> 运行挂卡程序了。是不是很简单！</p><h2 id="Ubuntu上部署"><a href="#Ubuntu上部署" class="headerlink" title="Ubuntu上部署"></a>Ubuntu上部署</h2><p>由于寝室晚上要熄灯。。。我们就想到了一种真·云挂卡的方案。</p><p>首先你要有一台能上 Steam 社区的服务器，然后在 Ubuntu 上安装 .NET Core 环境。</p><p>我的妈呀，我之前装了半天的 mono，要么告诉我不能运行，要么告诉我少库。其实网上那些是 2.0 的教程，但是 3.0 他换了！</p><p>安装 .NET Core 环境官方教程（记得选择 Linux）：<a href="https://www.microsoft.com/net/learn/get-started/linuxubuntu" target="_blank" rel="noopener">https://www.microsoft.com/net/learn/get-started/linuxubuntu</a></p><p>按照步骤来，如果他说少 libicu55，那么你把 Ubuntu 17.04，Ubuntu 17.10 的步骤也做一遍估计就好了。</p><p>安装好以后，先跳过以下步骤，如果后面不能运行，尝试这一步</p><pre><code>dotnet new console -o myApp</code></pre><p><strong>先跳过上面这步骤</strong></p><p>然后把下载下来的 ASF-linux 版本解压了，（不会的可以 Win 上解压丢回服务器）。</p><p>然后 chmod 赋权，然后 ./ArchiSteamFarm 即可正常运行。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实安装本身没有难度，就是你得找到你为啥错了 2333 像我就是因为搞不来依赖所以到处乱搞 最后冷静了一下 找了官方的环境安装教程就搞定了。</p><p>如果你愿意实现不需要手动输入令牌，那么你可以看这里：<a href="https://github.com/JustArchi/ArchiSteamFarm/wiki/Escrow" target="_blank" rel="noopener">https://github.com/JustArchi/ArchiSteamFarm/wiki/Escrow</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>sa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LAMP 快速部署</title>
    <link href="undefined2017/12/23/lamp/"/>
    <url>2017/12/23/lamp/</url>
    
    <content type="html"><![CDATA[<p>招新放题目上去的时候还要查来查去。。。如果可以写个脚本方便部署的话</p><a id="more"></a><p>其实也不会方便到哪里去 2333</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>以下是当时操作的</p><h2 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h2><pre><code>1  apt update2  apt upgrade3  mkdir kernel &amp;&amp; cd kernel4  apt install curl5  curl -O http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.14-rc1/linux-image-v4.14-rc1-generic_v4.14-rc1_amd64.deb6  ls7  dpkg -i linux-image-v4.14-rc1-generic_v4.14-rc1_amd64.deb 8  vim linux-image-v4.14-rc1-generic_v4.14-rc1_amd64.deb 9  rm linux-image-v4.14-rc1-generic_v4.14-rc1_amd64.deb 10  curl -O http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.14-rc1/linux-image-4.14.0-041400rc1-generic_4.14.0-041400rc1.201709162031_amd64.deb11  dpkg -i linux-image-4.14.0-041400rc1-generic_4.14.0-041400rc1.201709162031_amd64.deb 12  dpkg -l|grep linux-image13  apt purge linux-image-4.*14  apt purge linux-image-4.4.0-*15  dpkg -l|grep linux-image16  update-grub17  reboot18  echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf19  echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf20  sysctl -p21  sysctl net.ipv4.tcp_available_congestion_control22  sysctl net.ipv4.tcp_congestion_control23  lsmod | grep bbr24  curl pixiv.net25  apt install mysql-server26  apt install apache227  apt install php7.028  apt install php7.0-*29  cd /var/www/30  ls31  cd he32  cd html/33  ls34  vim index.php35  rm index.html 36  ls37  sudo /etc/init.d/apache2 restart38  sudo apt install libapache2-mod-php7.039  history</code></pre><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul><li>升级 bbr 是为了防止服务器阻塞</li><li>一定最后安装 php</li><li>安装完 php 测试 phpinfo 否则会导致源码直接下载</li><li>如果 php 没解析说明没有安装 libapache2-mod-php7.0</li></ul><h2 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h2><p>把 history 里的东西写进 1.sh 运行就行啦（我没试过 hhh）</p><pre><code>apt updateapt upgradeapt install mysql-serverapt install apache2apt install php7.0apt install php7.0-*apt install libapache2-mod-php7.0/etc/init.d/apache2 restart</code></pre><p>然后新建一个 test.php，存入内容</p><pre><code>&lt;?php    phpinfo();?&gt;</code></pre><p>试试能不能用就可以辣</p><p>发现我当时打错了好多命令 还干了什么不可名状的操作 2333</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>sa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫练习——四六级成绩抓取</title>
    <link href="undefined2017/08/26/cet4/"/>
    <url>2017/08/26/cet4/</url>
    
    <content type="html"><![CDATA[<p>辅导员突然给我打了个 QQ 电话，吓得我赶紧接起电话。我以为是要约谈我。突然问我会不会爬虫，嘛。当然是不会辣。QAQ。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>临时下载从未用过的 JetBrains PyCharm 2017.2.2 x64</li><li>很早安装但是不经常用的 Python 3.6</li><li>pip3 和库：requests BeautifulSoup4 xlwt</li><li>名单</li></ul><h2 id="爬虫部分"><a href="#爬虫部分" class="headerlink" title="爬虫部分"></a>爬虫部分</h2><h3 id="模拟抓取"><a href="#模拟抓取" class="headerlink" title="模拟抓取"></a>模拟抓取</h3><p>首先，我们肯定是要模拟自己正常查询的这一个过程，抓一个包，发现很明显的特征 /query?zkzh=&amp;xm=。事实上，我们通常还会变成 /query?zkzh=&amp;xm=&amp;yzm=。但是我们有特殊的绕过技巧 诶嘿。</p><p>然后使用 requests 和 beautifulsoup 可以轻松的分离出很多东西，我们发现我们要的东西都在 td 标签里，很快就分离了</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>但是输出来看，有个很恼火的东西，就是他长成这个样子</p><pre><code>张三                电子科技大学                英语四级                51002017******                    107                    177                    108                --                --</code></pre><p>哇 这可让我炸了毛了。我于是求助叶姐姐，问他正则匹配非空怎么弄。然后问来，发现不会用。于是跑去网上找资料，用 re 库，然后发现了更加痛苦的事情，我匹配串写不来=-=。。</p><p>想了好多办法，甚至想要用 C++ 来处理，感觉自己有点蠢，就先存了，然后在读回来，然后 split 掉，然后就可以拼成没有的串辣</p><p>大概像酱紫：<br>    李四 电子科技大学 英语六级 510020171<strong>**</strong> 86 145 96</p><p>嗯嗯 然后全部抓一遍就 ok 辣</p><h2 id="Excel处理"><a href="#Excel处理" class="headerlink" title="Excel处理"></a>Excel处理</h2><p>发现 excel 拖出来可以 txt 很好看，粘贴回去发现就是一坨。。。。</p><p>于是就写了第二个程序来处理。</p><p>处理过程非常简单，就对对应的格子写一下，然后人工排版一下美滋滋。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>听说爬虫是有框架的，来（lan）日（de）再（qu）说（xue）</p><p>爬虫应该是基本技能之一，啊喂=-=</p><h2 id="部分展示"><a href="#部分展示" class="headerlink" title="部分展示"></a>部分展示</h2><p><a href="https://github.com/EDGsheryl/CET-4-6-score-catch" target="_blank" rel="noopener">https://github.com/EDGsheryl/CET-4-6-score-catch</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM 输入输出优化技巧</title>
    <link href="undefined2017/05/18/acm-io-optimize/"/>
    <url>2017/05/18/acm-io-optimize/</url>
    
    <content type="html"><![CDATA[<p>在 ACM 竞赛中，时间效率是至关重要的一个指标。如果一个程序在输入输出上消耗太多时间，肯定影响算法本身占用的时间。而输入输出优化其实是一个老生长谈的问题</p><a id="more"></a><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在这里还是要说一句，比较喜欢 Leetcode 和 Topcoder 的输入输出形式：通过 class 来作为接口传递。我们就不用关心输入输出问题了。</p><h2 id="scanf和cin"><a href="#scanf和cin" class="headerlink" title="scanf和cin"></a>scanf和cin</h2><p>scanf 是 C 语言的读入，但是常常会忘记 &amp;</p><p>scanf 在格式化读入上有奇效。适用于一些骚读入。</p><pre><code class="cpp">scanf(&quot;%d+%d&quot;,&amp;a,&amp;b);//类似的东西。</code></pre><h2 id="printf和cout"><a href="#printf和cout" class="headerlink" title="printf和cout"></a>printf和cout</h2><p>printf 也是 C 语言的函数。</p><p>但是占位符这个东西呀，太麻烦了，尤其是 long long 的占位符。喵喵喵？</p><p>这时候就要说 cout 大法好</p><p>(update 2017-08-26:根据后来的经验，关同步的 cin 甚至可以比 scanf 快，但是 cout 速度就是提不上去，如果输出字符串，更加推荐 puts)</p><pre><code class="cpp">ios::sync_with_stdio(false);</code></pre><p>这句话，字面意思 iostream 的啥同步和标准io啥的关掉。</p><p>翻了翻别人的博客</p><pre><code>cin  cout之所以效率低是因为先把要输出的东西存入缓冲区，再输出导致效率降低而这段语句可以来打消iostream的输入 输出缓存可以节省许多时间，使效率与scanf与printf相差无几还有应注意的是scanf与printf使用的头文件应是stdio.h而不是 iostream。</code></pre><pre><code class="cpp">cin.tie(0)</code></pre><pre><code>在默认的情况下cin绑定的是cout每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</code></pre><h2 id="测试比较"><a href="#测试比较" class="headerlink" title="测试比较"></a>测试比较</h2><p>在 Codeforces 上，今天做了对比</p><p>同一题目：</p><ul><li>使用scanf,printf   平均用时342ms  内存19700 KB</li><li>使用优化的cincout   平均用时358ms  内存19800 KB</li><li>使用不优化cincout   平均用时1435ms 内存19800 KB</li></ul><p>由于 cf 的超多组测试，我们认为他比较平均吧。</p><p>可以看出 cin cout 和 printf scanf 其实可以相差比较小的。</p><h2 id="更加厉害的方法"><a href="#更加厉害的方法" class="headerlink" title="更加厉害的方法"></a>更加厉害的方法</h2><p>可以逐字符读入处理。甚至可以一下子全读进来瞎搞。</p><pre><code>可以但没有必要。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACM 校赛初赛 Writeup</title>
    <link href="undefined2017/03/30/acm-uestc/"/>
    <url>2017/03/30/acm-uestc/</url>
    
    <content type="html"><![CDATA[<p>心疼叶姐姐五点睡九点起来，一起约晚饭的时候都要吃睡去了，队友们很给力，配合得也不错 2333。希望决赛混个末等奖哈哈哈（逃）</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>There are infinite coins with values 1,2,5,10.</p><p>What’s the minimum numbers of coins should be picked that XX and YY can be made change for?</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Two integers X and Y. (1≤X,Y≤10^9)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>The minimum numbers of coins should be picked.</p><p>手动打表，然后发现 9 和 31 之类的数据需要特判什么的</p><p>大家都说第 24 个点有毒。</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[112][112];const int c[5] = {0, 1, 2, 5, 10};int i, j, k, l, x, y, xx, yy, minans;int ans[10]; int main(){    for (i = 0; i &lt;= 100; i++)        for (j = i; j &lt;= 100; j++)            a[i][j] = 1000000000;    a[0][0] = 0;    for (i = 0; i &lt;= 100; i++)        for (j = i; j &lt;= 100; j++)        {            for (k = 0; k &lt; 5; k++)                if (i &gt;= c[k])                    for (l = 0; l &lt; 5; l++)                        if (j &gt;= c[l])                        {                            x = i - c[k]; y = j - c[l];                            if (x &gt; y) swap(x, y);                            if (k == l || k * l == 0) a[i][j] = min(a[i][j], a[x][y] + 1);                            else a[i][j] = min(a[i][j], a[x][y] + 2);                        }        }    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);    if (x &gt; y) swap(x, y);    if (x &lt;= 100 &amp;&amp; y &lt;= 100)        printf(&quot;%d&quot;, a[x][y]);    else {        minans = 1000000000;        for (i = 1; i &lt;= 2; i++)            for (j = 1; j &lt;= 2; j++)            {                xx = x % 10;                yy = y % 10;                if (i == 2 &amp;&amp; x &gt; 20) xx += 10;                if (j == 2 &amp;&amp; y &gt; 20) yy += 10;                k = max((x - xx) / 10, (y - yy) / 10);                if (xx &gt; yy) swap(xx, yy);                k += a[xx][yy];                if (k &lt; minans) minans = k;            }        printf(&quot;%d&quot;, minans);    }    return 0;}</code></pre><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>Alice want to build n cities on a plane. A city can be regarded as a point. In order to keep communication between cities, the distance between each pair of cities must NOT greater than DD.</p><p>Bob has a weapon which can destroy all the cities in a circle with radius RR. After Alice building all the cities, Bob will select a city as the center and use his weapon once, and he will choose a way such that can destroy as many cities as possible.</p><p>To prevent the cities from being destroyed, Alice want choose a way to build her cities such that the number of cities will be destroyed by Bob can be as little as possible, can you tell her how to build these cities?</p><p>In order to make the problem easier, you can assume that D=2√RD=2R is always established, so the specific values of DD and RR will not affect the answer.</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>Only one line contains an integer n.</p><p>1≤n≤10^18.</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>The number of cities will be destroyed by Bob if Alice choose the optimal scheme to build her cities.</p><p>猜测将点分成三份就行，猜测正确。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;using namespace std;long long n; int main() {    cin&gt;&gt;n;    cout &lt;&lt; (n+2)/3;    return 0;}</code></pre><h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>You are given two numbers n and k.</p><p>You are required to construct a permutation p1,p2,…,pn of numbers 1,2,…,n such that there are exactly kk different numbers in |p1−p2|, |p2−p3|, …, |pn−1−pn|.</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>Only one line contains two integers n and k.</p><p>1≤k&lt;n≤100000.</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>Print n integers forming the permutation.</p><p>If there are multiple answers, print any of them.</p><p>If there are no such permutation, print -1.</p><p>先打表看看对应输出的解有什么特点，如果k=n-1的时候<br>发现是</p><p>1 n 2 (n-1) 3 (n-2) ……之类的形式，</p><p>考虑前面构造（k-1）个差值，最后差值为1，把没输出的输出了</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,k;int l,r;int main() {    cin&gt;&gt;n&gt;&gt;k;/*    if (k==1)     {        for (int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;;        return 0;    }*/    if (k&lt;1 || k&gt;=n)     {        cout&lt;&lt;-1;        return 0;    }    l=1;    r=n;    for (int i=1;i&lt;=k;i++)    {        if (i%2) cout&lt;&lt;(l++)&lt;&lt;&quot; &quot;;        else cout&lt;&lt;(r--)&lt;&lt;&quot; &quot;;    }    if (k%2==0)     {        for (l=l-1;r&gt;l;r--) cout&lt;&lt;r&lt;&lt;&quot; &quot;;    }    else     {        for (r=r+1;r&gt;l;l++) cout&lt;&lt;l&lt;&lt;&quot; &quot;;    }}# KThere are 10 tests.For the ith test, you should output i.## InputNo input.## OutputFor the ith test, you should output i.一看，神题，我去翻了翻卿学姐的博客，嗯，他暂时不会然后 C 和 C++ time 都被封锁了，第一反应是 java 写，不过没想到是 java 时间函数没被锁掉```javaimport java.io.*; import java.util.*;  public class Main {     public static void main(String[] args) throws Exception {            long t = System.currentTimeMillis();            while (t % 1000 &gt; 900) {                t = System.currentTimeMillis();            }            t = t / 1000 % 10;            if (t == 0) t = 10;            System.out.println (t);            t = System.currentTimeMillis();            while (t % 1000 &lt; 900) {                t = System.currentTimeMillis();            }    }  }</code></pre><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>There are N numbers where the ith is Ai.</p><p>In order to make the sum of them changed to S, you can make some numbers increased by one or decreased by one.</p><p>But you should spend Ci dollars to increase or decreased Ai by one, and the new Ai should satisfies Li≤Ai≤Ri.</p><p>Any number can be operated any times. What’s the minimum cost to make the sum of all numbers changed to S?</p><h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h2><p>The first line contains two integers N,S,</p><p>Next NN lines each line contains four integers Ai,Ci,Li,Ri.</p><p>1≤N≤1000,1≤S≤106,1≤Ci≤1000,0≤Li≤Ai≤Ri≤1000</p><h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h2><p>If there is no solutions, print impossible.</p><p>Otherwise, print one integer indicates the minimum cost to make the sum of all numbers changed to S.</p><p>转化为有限装包问题</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;cstdlib&gt;using namespace std;int n; int subnum;long long ans;int a[2020];int main() {    int x,y,z,zz;    cin&gt;&gt;n&gt;&gt;subnum;    for (int i=1;i&lt;=n;i++)    {        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;zz;        a[1010+y]+=zz-x;        a[1010-y]+=x-z;        subnum-=x;    }    if (subnum&gt;0)    {        for (int i=1;i&lt;=1000;i++)        {            int addnum=min(subnum,a[1010+i]);            ans+=i*addnum;            subnum-=addnum;        }        if (subnum)        {            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;            return 0;        }        else         {            cout&lt;&lt;ans&lt;&lt;endl;            return 0;        }     }     else    {        subnum=-subnum;        for (int i=1;i&lt;=1000;i++)        {            int addnum=min(subnum,a[1010-i]);            ans+=i*addnum;            subnum-=addnum;        }        if (subnum)        {            cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;            return 0;        }        else         {            cout&lt;&lt;ans&lt;&lt;endl;            return 0;        }     }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX 入门学习笔记</title>
    <link href="undefined2017/03/20/latex/"/>
    <url>2017/03/20/latex/</url>
    
    <content type="html"><![CDATA[<p>《离散数学》老师表示大家可以用 LaTeX 写课设，于是周末心血来潮准备用 LaTeX 写论文，哇安装起来很麻烦，最终在叶姐姐的指导下写完了QwQ。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>有很多方案，我一开始选择 latatexLive + atom 然后，我的 atom 挂了。。</p><p>Plan B：latexlive + sublime text 然后我卸载的时候，不知道卸了什么其他的东西，不过电脑好像没有坏。</p><p>最后选择了 Win 的套餐 CTeX</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="documentclass"><a href="#documentclass" class="headerlink" title="documentclass"></a>documentclass</h2><pre><code>    \documentclass[]{}</code></pre><p>文档设置，用 utf-8 参数来支持中文，不过不知道为什么，复制到其他地方就会导致打不开，可能默认用 ascii 打开文档导致溢出爆炸？</p><h2 id="usepackage"><a href="#usepackage" class="headerlink" title="usepackage"></a>usepackage</h2><p>载入库，类似与 Python 的 import 或者说是 C 系的 include</p><pre><code>    \usepackage{}    \usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}</code></pre><p>可以设置页面边距哟</p><h2 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h2><p>来闭合一个区域</p><pre><code>    \begin    \end</code></pre><h2 id="author"><a href="#author" class="headerlink" title="author"></a>author</h2><p>设置作者</p><pre><code>    \author{}</code></pre><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>设置文章标题</p><pre><code>    \title{}</code></pre><h2 id="maketitle"><a href="#maketitle" class="headerlink" title="maketitle"></a>maketitle</h2><p>让该页面加入标题作者时间信息</p><pre><code>    \maketitle</code></pre><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>格式化文章，真的很好用</p><pre><code>    \\(?:sub){0,1,2}section</code></pre><p>(上面是 \section 和 \subsection 和 \subsubsection 的意思，叶姐姐太强了)</p><h2 id="cite"><a href="#cite" class="headerlink" title="cite"></a>cite</h2><p>引用</p><pre><code>    \cite{}</code></pre><p>配合使用形成参考文献</p><pre><code>    \begin{thebibliography}{0}    \end{thebibliography}</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>\是换行</p><p>\par是换段落</p><p>\newpage换页</p><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><pre><code class="latex">    \documentclass[UTF8]{ctexart}    \usepackage[top=1in,bottom=1in,left=1.25in,right=1.25in]{geometry}    \usepackage{cite}    \usepackage{abstract}        \author{EDGsheryl}        \title{SQL技术研究综述}    \begin{document}        \maketitle        \begin{abstract}  随着计算机技术的迅速发展，在“信息时代”的21世纪，计算…… \textbf{关键词：SQL，库存管理系统}        \end{abstract}        \section{引言}        结构化查询语言(Structured Query Language)简称SQL，是一种特殊目的的编程\cite{Baidu}        \section{SQL技术简介}            \subsection{应用}            结构化查询语言SQL（STRUCTURED QUERY LANGUAGE）是最重要的关系数据……            \subsection{支持标准}            SQL 是1986年10 月由美国国家标准局（ANSI）通过的数据库语言美国标……            \subsection{其他版本SQL}            各种不同的数据库对SQL语言的支持与标准存在着细微的不同，这是因为，……        \section{SQL引擎工作原理及对比}            \subsection{ISAM}            ISAM是一个定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到……            \subsection{MyISAM}            MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所没有的索……            \subsection{HEAP}            HEAP允许只驻留在内存里的临时表格。驻留在内存里让HEAP要比ISAM和MYISAM都快，……            \subsection{InnoDB}            InnoDB数据库引擎都是造就MySQL灵活性的技术的直接产品，……\cite{yuanli,duibi}        \section{目前SQL技术中所存在的不足}            （1）安全问题。……\par （2）效率问题。……        \section{总结和展望}        SQL技术作为现有库存管理技术的主力军，必然有他的优势之处，随着非关系数据库的扩大使用，会减少关系型数据库的安全问题。        \begin{thebibliography}{0}            \bibitem{Baidu}            SQL ．维基百科，2015-01-31            \bibitem{yuanli}            李武．姚珺．数据库原理及应用．哈尔滨：哈尔滨工程大学出版社，2011：179            \bibitem{duibi}            Wilson ． 浅谈My SQL引擎的对比，2015        \end{thebibliography}    \end{document}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NJCTF2017 线上赛 Learning Note</title>
    <link href="undefined2017/03/15/NJCTF2017/"/>
    <url>2017/03/15/NJCTF2017/</url>
    
    <content type="html"><![CDATA[<p>比赛的时候，只有我一个人做题<br>而做题的时候只做了 misc<br>即使 misc 只做了签到题目 QWQ</p><a id="more"></a><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="Login"><a href="#Login" class="headerlink" title="Login"></a>Login</h2><p>随意注册账户，进去瞟一眼，需要 admin。</p><p>利用 php 和数据库中的字段长度进行截断，注册一个 admin +（好多空格）+（杂七杂八的东西）</p><p>会覆盖 admin 的密码</p><p>然后拿刚刚注册的密码用 admin 登录就可以了</p><p>（我以为第一题就是 sqli）</p><h2 id="Get-Flag"><a href="#Get-Flag" class="headerlink" title="Get Flag"></a>Get Flag</h2><p>用 flag=XXX</p><p>F12 可以看到 cat xxx：No such file or directory</p><p>我第一反应以为是 LFI，然后就开始找目录下有什么</p><p>结果是命令执行漏洞。。。</p><pre><code>userinput= 1 %26 find或者userinput= 1 %26 ls /</code></pre><p>都可以看到 flag</p><p>然后 cat $flag</p><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>进去第一眼就看到了 Ruby。。然后马上就放弃了。。</p><p>哇。</p><p>别人的 writeup 里说直接拿源码。。。</p><p>哇。。。</p><p>源码呢QAQ</p><p>关注到 schema.rb 文件的 user 表，有一个 t.boolean “admin”</p><p>在注册的时候传入参数， user[admin]=1</p><p>之后在 /user 页面源代码找到了 flag</p><h2 id="Come-On"><a href="#Come-On" class="headerlink" title="Come On"></a>Come On</h2><p>随便搜一下</p><p>发现多了 ?key=1</p><p>应该是一道 sqli，宽字符注入</p><p>发现 like 没被过滤，构造 %df’||(select(hex(flag))from(flag))like(0x)%23 去模糊匹配</p><p>这时候就需要写个脚本去打完</p><h2 id="Chall-I"><a href="#Chall-I" class="headerlink" title="Chall I"></a>Chall I</h2><p>前端和小姨子跑了，没办法扫描都得从头学起，干脆前后端都用 js 写吧</p><p>界面上都没有可以点的东西，唉= =</p><pre><code>https://www.smrrd.de/nodejs-hacking-challenge-writeup.html</code></pre><p>还有的队伍，去 GitHub 上找 bibibibi</p><p>然后 /admin 里去登录，用纯数字去登录 N 次，大概原理是 js 的 Buffer 遇到数字参数时会将内存数据泄露出来。</p><p>payload=ximaz</p><p>从 flag 给我们的 NJCTF{P1e45e_s3arch_th1s_s0urce_cod3_0lddriver} 确实是找源代码</p><h2 id="Wallet"><a href="#Wallet" class="headerlink" title="Wallet"></a>Wallet</h2><p>这题听说要花钱解密</p><p>源码在根目录下 /<a href="http://www.zip" target="_blank" rel="noopener">www.zip</a>  (没做过谁知道卧槽。。。)</p><p>然后弱密码是 njctf2017…还有 php 混淆。。。</p><p>然后是 php 的弱类型 </p><pre><code>https://www.whitehatsec.com/blog/magic-hashes/</code></pre><p>然后 sqli </p><p>我后来做的时候，还去 db.php 里搞。。。是在 admin.php</p><p>id=0 不能大于0，否则就查出东西了。。</p><h2 id="Guess"><a href="#Guess" class="headerlink" title="Guess"></a>Guess</h2><pre><code>php://filter/convert.base64-encode/resource=</code></pre><pre><code class="php">&lt;?phperror_reporting(0);function show_error_message($message){    die(&quot;&lt;div class=\&quot;msg error\&quot; id=\&quot;message\&quot;&gt;    &lt;i class=\&quot;fa fa-exclamation-triangle\&quot;&gt;&lt;/i&gt;$message&lt;/div&gt;&quot;);}function show_message($message){    echo(&quot;&lt;div class=\&quot;msg success\&quot; id=\&quot;message\&quot;&gt;    &lt;i class=\&quot;fa fa-exclamation-triangle\&quot;&gt;&lt;/i&gt;$message&lt;/div&gt;&quot;);}function random_str($length = &quot;32&quot;){    $set = array(&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;, &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;,        &quot;g&quot;, &quot;G&quot;, &quot;h&quot;, &quot;H&quot;, &quot;i&quot;, &quot;I&quot;, &quot;j&quot;, &quot;J&quot;, &quot;k&quot;, &quot;K&quot;, &quot;l&quot;, &quot;L&quot;,        &quot;m&quot;, &quot;M&quot;, &quot;n&quot;, &quot;N&quot;, &quot;o&quot;, &quot;O&quot;, &quot;p&quot;, &quot;P&quot;, &quot;q&quot;, &quot;Q&quot;, &quot;r&quot;, &quot;R&quot;,        &quot;s&quot;, &quot;S&quot;, &quot;t&quot;, &quot;T&quot;, &quot;u&quot;, &quot;U&quot;, &quot;v&quot;, &quot;V&quot;, &quot;w&quot;, &quot;W&quot;, &quot;x&quot;, &quot;X&quot;,        &quot;y&quot;, &quot;Y&quot;, &quot;z&quot;, &quot;Z&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;);    $str = &#39;&#39;;    for ($i = 1; $i &lt;= $length; ++$i) {        $ch = mt_rand(0, count($set) - 1);        $str .= $set[$ch];    }    return $str;}session_start();$reg=&#39;/gif|jpg|jpeg|png/&#39;;if (isset($_POST[&#39;submit&#39;])) {    $seed = rand(0,999999999);    mt_srand($seed);    $ss = mt_rand();    $hash = md5(session_id() . $ss);    setcookie(&#39;SESSI0N&#39;, $hash, time() + 3600);    if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) {        show_error_message(&quot;Upload ERROR. Return Code: &quot; . $_FILES[&quot;file-upload-field&quot;][&quot;error&quot;]);    }    $check1 = ((($_FILES[&quot;file-upload-field&quot;][&quot;type&quot;] == &quot;image/gif&quot;)            || ($_FILES[&quot;file-upload-field&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)            || ($_FILES[&quot;file-upload-field&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)            || ($_FILES[&quot;file-upload-field&quot;][&quot;type&quot;] == &quot;image/png&quot;))        &amp;&amp; ($_FILES[&quot;file-upload-field&quot;][&quot;size&quot;] &lt; 204800));    $check2=!preg_match($reg,pathinfo($_FILES[&#39;file-upload-field&#39;][&#39;name&#39;], PATHINFO_EXTENSION));    if ($check2) show_error_message(&quot;Nope!&quot;);    if ($check1) {        $filename = &#39;./uP1O4Ds/&#39; . random_str() . &#39;_&#39; . $_FILES[&#39;file-upload-field&#39;][&#39;name&#39;];        if (move_uploaded_file($_FILES[&#39;file-upload-field&#39;][&#39;tmp_name&#39;], $filename)) {            show_message(&quot;Upload successfully. File type:&quot; . $_FILES[&quot;file-upload-field&quot;][&quot;type&quot;]);        } else show_error_message(&quot;Something wrong with the upload...&quot;);    } else {        show_error_message(&quot;only allow gif/jpeg/png files smaller than 200kb!&quot;);    }}?&gt;</code></pre><p>可以把自己的 session_id 填进去 也可以干脆清空，这样就只有 $ss 了，然后就能根据 session 把 $seed 跑出来了，然后就能跑出文件目录了。</p><p>用 php 跑吧，如果用 python 跑可能跑不出来</p><p>有点怪怪的，要吃饭去上课了。。不管了</p><p>学会了 php 伪协议和一句话木马和 getshell 是什么 QWQ</p><h2 id="Be-Admin"><a href="#Be-Admin" class="headerlink" title="Be Admin"></a>Be Admin</h2><p>首先是 ./index.php.bak 源码泄露</p><p>然后是 padding oracle 攻击</p><p>鉴于没学密码学相关只是，就暂时先放一下</p><h2 id="Text-Wall"><a href="#Text-Wall" class="headerlink" title="Text Wall"></a>Text Wall</h2><p>源码泄露 ， ./.index.php.swo</p><p>ctf 的套路好多。。。web 是需要积累的。嗯。</p><p>还要知道反序列化数据</p><pre><code>return highlight_file(&#39;hiehiehie.txt&#39;, true).highlight_file($this-&gt;source, true);list=&quot;f3a6de2497f71356a3995e26a1f4f64ae48e80b1a:1:{i:0;O:8:&quot;filelist&quot;:1:{s:6:&quot;source&quot;;s:9:&quot;index.php&quot;;}}&quot;</code></pre><p>读出 index.php，里面有 flag 的地址，再读 flag。</p><h2 id="Pictures’-wall"><a href="#Pictures’-wall" class="headerlink" title="Pictures’ wall"></a>Pictures’ wall</h2><p>我还说第一步 sqli，结果直接进去。。。</p><p>发现我们不是 root</p><p>我居然换了个 root，进去没用</p><p>看 wp，是改 header，host=127.0.0.1</p><p>然后上传图片 trick  </p><pre><code>&lt;script language=&quot;php&quot;&gt;system($_POST[va]);&lt;/script&gt;</code></pre><p>做题有些时候不要过于依赖浏览器，用 burp QwQ。</p><p>还有毒瘤们把 flag 删掉了！！！QAQ</p><h2 id="Chall-2"><a href="#Chall-2" class="headerlink" title="Chall 2"></a>Chall 2</h2><p>chall 1 的基础上</p><p>用源码搭建本地服务器，获得 admin 的 cookies</p><h2 id="Be-Logical"><a href="#Be-Logical" class="headerlink" title="Be Logical"></a>Be Logical</h2><p>504 Gateway Time-out</p><p>可能弱者不配看题吧。</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="check-in"><a href="#check-in" class="headerlink" title="check in"></a>check in</h2><p>来QQ群签到啦</p><h2 id="Knock"><a href="#Knock" class="headerlink" title="Knock"></a>Knock</h2><p>是单值对应密码？？？</p><p>丢 quipqiup，然后找出对应关系，然后根据….<em>…</em></p><p>..对应了单词_对应分割</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><p>100 的都看不懂</p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><p>各位哥哥姐姐们，有 libc 嘛 QwQ</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就像学长说的，web 是需要积累的。</p><p>但是感觉并没有 ctf 留着他们的服务器，给我们看着 writeup 再次尝试。。</p><p>有点心塞。</p><p>做题的时候 总感觉好像就卡在那儿，差一点点，出来看方向不对</p><p>不会 ctf，不会开发，不会文化课，感觉啥都不会，天天混着混着，感觉越来越迷茫了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#面向对象的学习笔记</title>
    <link href="undefined2017/03/05/csharp/"/>
    <url>2017/03/05/csharp/</url>
    
    <content type="html"><![CDATA[<p>像我这种 C with class 的使用者，把 class 拿来当 struct 来用，还用来做 OJ 的题目之外，好像没有什么其他用途了。以前看到 C++ 里面类的时候，也只是大概浏览了一下，现在我觉得可以边看边学边记。</p><a id="more"></a><p>学 Java 的时候跑回来翻了翻，发现一大堆错 23333。</p><p>深入学习下去以后。在我学习了 Java 以后，CSharp 的设计真的很像很像 java，甚至我觉得把这篇文章改改，就变成了 java 的学习笔记（笑）。一开始可能会有很多不懂的地方，都是学习了 Java 之后才能理解，写了一点 C++ 之后才能理解的。我不能说我完全掌握了，但是还是能解释一些现象。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我觉得，面对对象这一概念是模糊的，你知道有这个东西，你知道怎么使用，却很难描述清楚它是什么。</p><p>百度百科的解释：</p><pre><code>面向对象(Object Oriented,OO)是软件开发方法。起初，“面向对象”是专指在程序设计中采用封装、继承、多态等设计方法。</code></pre><p>你知道他是好东西就行了 =w=</p><h2 id="C-封装"><a href="#C-封装" class="headerlink" title="C# 封装"></a>C# 封装</h2><h3 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h3><p>Public 访问修饰符 允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问。</p><h3 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h3><p>Private 访问修饰符 允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</p><h3 id="Protected"><a href="#Protected" class="headerlink" title="Protected"></a>Protected</h3><p>Protected 访问修饰符 允许子类访问它的基类的成员变量和成员函数。</p><h3 id="Internal"><a href="#Internal" class="headerlink" title="Internal"></a>Internal</h3><p>Internal 访问说明符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。internal 访问是对同一程序集内可访问</p><h3 id="Protected-internal"><a href="#Protected-internal" class="headerlink" title="Protected internal"></a>Protected internal</h3><p>Protected Internal 访问修饰符允许一个类将其成员变量和成员函数对同一应用程序内的子类以外的其他的类对象和函数进行隐藏。</p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>public 是大家都可以访问的，用来访问修改 private 的成员变量和成员函数。protected 是基类和子类才能访问。internal 是在同一程序集中可访问。</p><h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C# 类定义"></a>C# 类定义</h2><pre><code class="csharp">&lt;access specifier&gt; class  class_name {    // member variables    &lt;access specifier&gt; &lt;data type&gt; variable1;    &lt;access specifier&gt; &lt;data type&gt; variable2;    ...    &lt;access specifier&gt; &lt;data type&gt; variableN;    // member methods    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)     {        // method body     }    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)     {        // method body     }    ...    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)     {        // method body     }}</code></pre><ul><li><p>访问标识符 <access specifier> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 internal，成员的默认访问标识符是 private。</p></li><li><p>数据类型 <data type> 指定了变量的类型，返回类型 <return type> 指定了返回的方法返回的数据类型。</p></li><li><p>如果要访问类的成员，您要使用点（.）运算符。</p></li><li><p>点运算符链接了对象的名称和成员的名称。</p></li></ul><h2 id="C-中的构造函数"><a href="#C-中的构造函数" class="headerlink" title="C# 中的构造函数"></a>C# 中的构造函数</h2><p>类的 构造函数 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。</p><p>构造函数是很方便的，相当于初始化的功能。构造函数可以有多个，根据传参类型不同来区分。</p><pre><code class="csharp">using System;namespace LineApplication{   class Line   {      private double length;   // 线条的长度      public Line(double len)  // 参数化构造函数      {         Console.WriteLine(&quot;对象已创建，length = {0}&quot;, len);         length = len;      }  public Line()      {         Console.WriteLine(&quot;对象已创建&quot;);      }      public void setLength( double len )      {         length = len;      }      public double getLength()      {         return length;      }      static void Main(string[] args)      {         Line line = new Line(10.0);         Console.WriteLine(&quot;线条的长度： {0}&quot;, line.getLength());          // 设置线条长度         line.setLength(6.0);         Console.WriteLine(&quot;线条的长度： {0}&quot;, line.getLength());          Console.ReadKey();      }   }}</code></pre><h2 id="C-中的析构函数"><a href="#C-中的析构函数" class="headerlink" title="C# 中的析构函数"></a>C# 中的析构函数</h2><p>类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p><pre><code class="csharp">using System;namespace LineApplication{  class Line   {      private double length;   // 线条的长度      public Line()  // 构造函数      {         Console.WriteLine(&quot;对象已创建&quot;);      }      ~Line() //析构函数      {         Console.WriteLine(&quot;对象已删除&quot;);      }      public void setLength( double len )      {         length = len;      }      public double getLength()      {         return length;      }      static void Main(string[] args)      {         Line line = new Line();         // 设置线条长度         line.setLength(6.0);         Console.WriteLine(&quot;线条的长度： {0}&quot;, line.getLength());                 }   }}</code></pre><h2 id="C-类的静态成员"><a href="#C-类的静态成员" class="headerlink" title="C# 类的静态成员"></a>C# 类的静态成员</h2><p>我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。<br>关键字 static 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。您也可以在类的定义内部初始化静态变量。</p><p>您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。下面的实例演示了静态函数的用法：</p><p>大概是所有实例共享一个参数的意思。</p><h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C# 继承"></a>C# 继承</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>写新程序的时候，要设计新的类，继承了已有的类。已有的类被称为的基类，新的类被称为派生类。</p><pre><code class="csharp">&lt;acess-specifier&gt; class &lt;base_class&gt;{ ...}class &lt;derived_class&gt; : &lt;base_class&gt;{ ...}</code></pre><h3 id="基类的初始化"><a href="#基类的初始化" class="headerlink" title="基类的初始化"></a>基类的初始化</h3><p>派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。</p><pre><code class="csharp">&lt;acess-specifier&gt; class &lt;base_class&gt;{ ...}class &lt;derived_class&gt; : &lt;base_class&gt;{ public &lt;derived&gt; (double l, double w) : base (l, w) {}}</code></pre><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>首先我们需要知道什么是多重继承。。。（不懂2333）</p><p>C# 不支持多重继承。但是，可以使用接口来实现多重继承。</p><h2 id="C-多态性"><a href="#C-多态性" class="headerlink" title="C# 多态性"></a>C# 多态性</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。</p><h3 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h3><p>动态多态性是通过 抽象类 和 虚方法 实现的。我在刚刚看到这个东西的时候是看不懂的。</p><p>首先我们需要理解一下抽象类。</p><p>然后再了解一下虚方法。</p><p>我在写 C++ 实验的时候，大概了解到动态多态性是什么了。基类和派生类（或者说子类和父类）有完全同名的函数，我们在使用父类的时候，他会去使用父类里的那个成员函数，而使用子类的时候，会去调用子类的成员函数。我们用基类指针指向一个父类或者子类的时候，他会根据指向的内容是什么然后做出判断去调用哪一个。这听上去有点不可思议，有一点反“C 常识”。</p><p>CSharp 是没有指针的，所以替代品就是引用了。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>C# 允许使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。抽象类包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><p>下面是有关抽象类的一些规则：</p><ul><li><p>不能创建一个抽象类的实例。</p></li><li><p>不能在一个抽象类外部声明一个抽象方法。</p></li><li><p>通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。</p></li></ul><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用虚方法。虚方法是使用关键字 virtual 声明的。虚方法可以在不同的继承类中有不同的实现。对虚方法的调用是在运行时发生的。</p><h2 id="C-接口"><a href="#C-接口" class="headerlink" title="C# 接口"></a>C# 接口</h2><p>Interface 接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 “是什么” 部分，派生类定义了语法合同 “怎么做” 部分。</p><p>粗粗一想 interface 和 abstract class 两者好像没啥区别，也可以互相替换。</p><p>但是其实区别也有，C# 中不允许多重继承，但是可以实现多个 interface。可以算是向多重继承的一种妥协。</p>]]></content>
    
    
    
    <tags>
      
      <tag>lang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF for ビギナーズ 2016 金沢</title>
    <link href="undefined2016/12/15/CTF2016%E9%87%91%E6%B2%A2/"/>
    <url>2016/12/15/CTF2016%E9%87%91%E6%B2%A2/</url>
    
    <content type="html"><![CDATA[<p>这是某个夜黑风高的晚上，室友都出去了，就我一人在寝室默默做题 QwQ</p><a id="more"></a><h2 id="vigenere"><a href="#vigenere" class="headerlink" title="vigenere"></a>vigenere</h2><pre><code>key:VIGENER?????p:SECCON{?????????????????????????????????}c:LMIG}RPEDOEEWKJIQIWKJWMNDTSR}TFVUFWYOCBAJBQ</code></pre><p>然后求密文，密文的 MD5 值已经给出</p><p>学长的做法是把 MD5 值发布出去。QAQ</p><p>由于我不知道发布出去的姿势，而且后面五位是不知道的，所以只好暴力枚举</p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;char a[30][30];string d;char x,y;int main(){    freopen(&quot;ans.txt&quot;,&quot;w&quot;,stdout);    for (int i=0;i&lt;28;i++) { getchar();getchar(); cin&gt;&gt;d;        for (int o=0;o&lt;28;o++) a[i][o]=d[o];        getchar();    }    string initt=&quot;                                           &quot;;    string key=&quot;VIGENER     &quot;;    string ansss=&quot;LMIG\\RPEDOEEWKJIQIWKJWMNDTSR\\TFVUFWYOCBAJBQ&quot;;    for (key[7]=&#39;A&#39;;key[7]&lt;=&#39;Z&#39;;key[7]++)        for (key[8]=&#39;A&#39;;key[8]&lt;=&#39;Z&#39;;key[8]++)            for (key[9]=&#39;A&#39;;key[9]&lt;=&#39;Z&#39;;key[9]++)                for (key[10]=&#39;A&#39;;key[10]&lt;=&#39;Z&#39;;key[10]++)                    for (key[11]=&#39;A&#39;;key[11]&lt;=&#39;Z&#39;;key[11]++)                    {                        for (int i=0;i&lt;ansss.size();i++)                        {                            for (int o=0;o&lt;28;o++)                             if (a[o][key[i%12]-&#39;A&#39;]==ansss[i]) cout&lt;&lt;(char)(o+&#39;A&#39;);                        }                        bool flag=1;                        for (int i=7;i&lt;initt.size()-1;i++) if (initt[i]==&#39;[&#39; || initt[i]==&#39;\\&#39;) flag=0;                        if (initt[initt.size()-1]!=&#39;\\&#39;) flag=0;                        initt[6]=&#39;{&#39;;                        initt[initt.size()-1]=&#39;}&#39;;                        if (flag) cout&lt;&lt;initt&lt;&lt;endl;                    } }</code></pre><p>生成了所有可能的 flag，然后用 Python 去算 MD5 值，跟给的值比较</p><pre><code class="python">import hashlibf = open(&quot;ans.txt&quot;)line = f.readline()while line:    m = hashlib.md5()    m.update(line)    psw = m.hexdigest()    if (psw==&#39;f528a6ab914c1ecf856a1d93103948fe&#39;) : print (line)    m = hashlib.md5()    m.update(line.lower())    psw = m.hexdigest()    if (psw==&#39;f528a6ab914c1ecf856a1d93103948fe&#39;) : print (line)    line = f.readline()print &#39;noanswer&#39;</code></pre><h2 id="voip"><a href="#voip" class="headerlink" title="voip"></a>voip</h2><p>一道流量分析，不过居然不是 TCP 的，是 UDP 的，然后发现里面好像在跟什么对话？</p><p>将里面的东西处理一下，发现是一个 .au 的音频文件。</p><p>然后听上去，卧槽根本听不清楚</p><p>传不上来- -</p><p>有兴趣的私我，我给你听听=w=</p><h2 id="Anti-Debugging"><a href="#Anti-Debugging" class="headerlink" title="Anti-Debugging"></a>Anti-Debugging</h2><h3 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h3><p>直接发现，I have a pen. 输进去应该就对了。</p><p>不过我做的时候，比赛结束了。。哈？</p><p>update(2016.12.15)：</p><h3 id="别人的解法"><a href="#别人的解法" class="headerlink" title="别人的解法"></a>别人的解法</h3><p>Windowsのexe問題。Windows環境があれば、OllyDbgとIDAですぐ解けます。</p><p>anti-debugが入る前(0x4013A3あたり)でbreak<br>eipを復号処理 0x401663に飛ばす<br>check(0x401737)あたりでbreak<br>flagはスタックに書いてある<br>SECCON{check_Ascii85}<br>ちゃんとやるならパッチをあてるとかですかね。</p><p>quote：<a href="http://jptomoya.hatenablog.com/entry/2016/12/12/140136" target="_blank" rel="noopener">http://jptomoya.hatenablog.com/entry/2016/12/12/140136</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是不会稍微难的题目。之做出了300+人都能解出的题目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HCTF2016 Learning note</title>
    <link href="undefined2016/11/30/HCTF2016/"/>
    <url>2016/11/30/HCTF2016/</url>
    
    <content type="html"><![CDATA[<p>嗯，别人家叫做 writeup，叫 writedown 也不合适呢。。QwQ</p><a id="more"></a><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><p>没有一道会的 QAQ</p><p>（update 2017.3.2）都是RSA。。</p><h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h2><p>没一道会的=w=</p><h3 id="最正常的逆向"><a href="#最正常的逆向" class="headerlink" title="最正常的逆向"></a>最正常的逆向</h3><p>被 fastcall 口胡去了，只是验证长度？（没再次尝试过）</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>misc 有很多很友好的送分题=w=</p><h3 id="MISC签到"><a href="#MISC签到" class="headerlink" title="MISC签到"></a>MISC签到</h3><p>记录了对某终端的操作</p><p>给了一段 Python 代码和终端操作</p><p>看来 Python 还是 Linux 上写好qwq</p><h3 id="隐写1：-pic-again"><a href="#隐写1：-pic-again" class="headerlink" title="隐写1：(pic again)"></a>隐写1：(pic again)</h3><p>学长做出来的</p><pre><code>Quote:&quot;LSB隐写就是修改RGB颜色分量的最低二进制位（LSB），而人类的眼睛不会注意到这前后的变化&quot;</code></pre><p>反正还是没听懂- -</p><p>看上去 0 通道有异常，把他弄出来，是一个 rar</p><p>修复后里面是一个可执行程序，丢到 Linux 运行得到 Flag</p><h3 id="隐写2"><a href="#隐写2" class="headerlink" title="隐写2"></a>隐写2</h3><p>FFT 变换，没装 Matlab 不进行实验了就 qwq</p><h3 id="48小时精通CPP"><a href="#48小时精通CPP" class="headerlink" title="48小时精通CPP"></a>48小时精通CPP</h3><p>（题目给 hint：别想了，那怎么可能？   23333）</p><p>把给的东西翻译成函数，然后暴力每一个字符就可以辣~~</p><h3 id="gogogo"><a href="#gogogo" class="headerlink" title="gogogo"></a>gogogo</h3><p>魂斗罗，下载个 nes 模拟器，然后愉快的玩耍吧</p><p>瓦打通关哒哟~~</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="level-1-2099年的flag"><a href="#level-1-2099年的flag" class="headerlink" title="level-1 2099年的flag"></a>level-1 2099年的flag</h3><p>一看就是改 http header 嘛。</p><p>嗯 ios99 居然是错的。</p><h4 id="bingo-way"><a href="#bingo-way" class="headerlink" title="bingo way"></a>bingo way</h4><pre><code>Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1Mozilla/5.0 (iPhone; CPU iPhone OS 99_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1</code></pre><p>略坑啊。比赛经验为 0。。</p><h3 id="level-2-restful"><a href="#level-2-restful" class="headerlink" title="level-2 restful"></a>level-2 restful</h3><p>450 的梗，出题人一定是个死宅</p><p>在 firefox 里改 GET-&gt;PUT 然后就。。405了</p><p>换用 Burp 才行。</p><p>一直没理解 RESTful 是什么</p><h3 id="level-2-giligili"><a href="#level-2-giligili" class="headerlink" title="level-2 giligili"></a>level-2 giligili</h3><p>出 web 的一定是死宅 mdzz</p><p>翻译代码</p><p>（好像有什么神奇姿势可以学习，下次试试 2016.11.30）</p><h3 id="level-2-兵者多诡诈"><a href="#level-2-兵者多诡诈" class="headerlink" title="level-2 兵者多诡诈"></a>level-2 兵者多诡诈</h3><p>似乎是个上传题？</p><p>PHP Null Byte Injection</p><p>（找个时间学学 2016.11.30）</p><h3 id="level-3-必须比香港记者跑得快"><a href="#level-3-必须比香港记者跑得快" class="headerlink" title="level-3 必须比香港记者跑得快"></a>level-3 必须比香港记者跑得快</h3><p>我跟 10miric 在寝室里，两个人输入好数字，同时按下去。。</p><p>结果还是不够快- -</p><p>那我就不理解了。。。（难道写 Python 更快？？？）</p><p>(update 2016.12.1)</p><p>看了 Python 的 exp 是采用多线程，不快都怪了 - -</p><p>做题目的步骤是扫描器扫出 .git，然后想到规范，肯定有 readme.md</p><p>得到了源码以后，配置了一下 MySQL</p><p>大概是一开始注册到 users，然后再多弄个 level，就只能重新建个表 role</p><p>然后 login 查询时到 role 查询的，赋值 level 之前，$res=array()；</p><p>可能 array 返回了个随机数？？？？？</p><p>——————————————————————————</p><p>从来没有接触多线程的程序=w=，是个良好的开端</p><h3 id="level-3-guestbook"><a href="#level-3-guestbook" class="headerlink" title="level-3 guestbook"></a>level-3 guestbook</h3><p>一直不理解 guestbook 有什么好日的。。</p><p>原来会执行 xss 呀。</p><p>等我学一学QwQ（2016.11.30）</p><h3 id="level-4-大图书馆的牧羊人"><a href="#level-4-大图书馆的牧羊人" class="headerlink" title="level-4 大图书馆的牧羊人"></a>level-4 大图书馆的牧羊人</h3><p>做 web 题，而我却不会用扫描器，可怕可怕（2016.11.30）</p><p>容我先学个 shell（2016.11.30）</p><h3 id="level-4-secret-area"><a href="#level-4-secret-area" class="headerlink" title="level-4 secret area"></a>level-4 secret area</h3><h3 id="level-4-web选手的自我修养"><a href="#level-4-web选手的自我修养" class="headerlink" title="level-4 web选手的自我修养"></a>level-4 web选手的自我修养</h3><h3 id="level-4-AT-Field-1"><a href="#level-4-AT-Field-1" class="headerlink" title="level-4-AT Field_1"></a>level-4-AT Field_1</h3><h3 id="level-5-魔法禁书目录"><a href="#level-5-魔法禁书目录" class="headerlink" title="level-5 魔法禁书目录"></a>level-5 魔法禁书目录</h3><p>（容我先吃个饭 2016.11.30）</p><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p>报警了 110</p><h2 id="赛后小记"><a href="#赛后小记" class="headerlink" title="赛后小记"></a>赛后小记</h2><p>早上还在嘲笑 SU 的被封号了 2333</p><p>然后下午因为逆向题自带防作弊验证，两个矩阵不一样导致两个队伍被封号了= =</p><p>这就很尴尬了。。。</p><p>这次做 ctf，感觉我都没在做 web，不是 misc 划水就是在 reverse 划水。。好像还看了看 CRYPTO 哈？</p><p>学长们太强辣 qwq</p><p>我搞了两道 misc 哟~~ : )</p><p>反思现在，状态很不好，有点迷茫吧。<s>可能是看 sqli？</s>状态有待调整（2016.11.30）</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>